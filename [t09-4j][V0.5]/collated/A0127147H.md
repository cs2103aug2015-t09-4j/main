# A0127147H
###### .metadata\.plugins\org.eclipse.core.resources\.history\1a\80e91cadf986001517b1b65a1f8245b9
``` 
	public void executeRedo() throws IOException, Exception {
		if (!undoneStates.isEmpty()) {
			lastStates.push(FileStorage.readStringAsString(path));
			FileStorage.clear();
			FileStorage.writeStringAsString(undoneStates.pop());
		} else {
			throw new Exception("Already at current");
		}
		updateLists();
	}

	public String[] getStringForParsing(String[] commandParts) {
		String[] stringToParse = new String[commandParts.length - 1];
		for (int i = 1; i < commandParts.length; i++) {
			stringToParse[i - 1] = commandParts[i];
		}
		stringToParse[0] = "add";
		return stringToParse;
	}

	public void addTaskToList(Task newTask) {
		switch (newTask.getTaskType()) {
		case TASKTYPE_FLOATING:
			floatingTasks.add(newTask);
			listType = "floating";
			break;
		case TASKTYPE_DEADLINE:
			this.fillUpTime(newTask);
			deadlineTasks.add(newTask);
			date[1] = newTask.getTaskEndDate();
			listType = "date";
			break;
		case TASKTYPE_EVENT:
			this.fillUpTime(newTask);
			eventTasks.add(newTask);
			date[1] = newTask.getTaskStartDate();
			listType = "date";
			break;
		}
	}

	public Task deleteTaskFromList(int deleteId) throws Exception {
		Task deletedTask = new Task();
		switch (listType) {
		case TASKTYPE_FLOATING:
			deletedTask = removeTaskFromFloatingList(deleteId);
			break;
		case TASKTYPE_DEADLINE:
			if (deleteId > overdueTasks.size()) {
				int temp = deleteId - overdueTasks.size();
				deletedTask = removeTaskFromDeadlineList(temp);
			} else {
				deletedTask = removeTaskFromOverdueList(deleteId);
			}
			break;
		case TASKTYPE_EVENT:
			deletedTask = removeTaskFromEventList(deleteId);
			break;
		case TASKTYPE_overdue:
			deletedTask = removeTaskFromOverdueList(deleteId);
			break;
		case TASKTYPE_done:
			deletedTask = removeTaskFromDoneList(deleteId);
			break;
		}
		selectedTask = deletedTask;
		return deletedTask;
	}

	public Task removeTaskFromFloatingList(int deleteId) throws Exception {
		if (floatingTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = floatingTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromDeadlineList(int deleteId) throws Exception {
		if (deadlineTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = deadlineTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromEventList(int deleteId) throws Exception {
		if (floatingTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = eventTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromOverdueList(int deleteId) throws Exception {
		if (floatingTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = overdueTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromDoneList(int deleteId) throws Exception {
		if (doneTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = doneTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	/*
	 * get what user wants to view date e.g. navigate 010101
	 */

	public void executeUpdate() throws IOException, ClassNotFoundException {
		logger.log(Level.INFO, "Executing Update");
		String currentDate = parser.getCurrentDate();
		for (int i = 0; i < deadlineTasks.size(); i++) {
			Task taskToCheck = deadlineTasks.get(i);
			String endDate = taskToCheck.getTaskEndDate();
			if (parser.endDatePassed(currentDate, endDate) && (!taskToCheck.getTaskType().equals(TASKTYPE_overdue))) {
				taskToCheck.setTaskType(TASKTYPE_overdue);
			}
		}

		for (int j = 0; j < eventTasks.size(); j++) {
			Task taskToCheck = eventTasks.get(j);
			String endDate = taskToCheck.getTaskEndDate();
			if (parser.endDatePassed(currentDate, endDate) && (!taskToCheck.getTaskType().equals(TASKTYPE_done))) {
				taskToCheck.setTaskType(TASKTYPE_done);
			}
		}
	}

	public ArrayList<Task> executeSort(ArrayList<Task> list) {
		list = Sort.normal_sort(list);
		return list;
	}

	public void saveLastState() throws Exception, IOException {
		String currentState = FileStorage.readStringAsString(path);

		if (!currentState.equals(lastState)) {
			lastStates.push(currentState);
			lastState = currentState;
			undoneStates = new Stack<String>();
		}
	}
	
	public void fillUpTime(Task newTask) {
		if (newTask.getTaskType().equals("floating")) {
			return;
		} else if (newTask.getTaskType().equals("event")) {
			int newStartTime = roundDownTime(newTask.getTaskStartTime());
			int newEndTime = roundUpTime(newTask.getTaskEndTime());
			for (int counter = newStartTime; counter < newEndTime; counter++) {
				newTask.setEventTime(counter);
			}
		} else {
			int newEndTime = roundDownTime(newTask.getTaskEndTime());
			newTask.setDeadlineTime(newEndTime);
		}
	}

	public int roundDownTime(String time) {
		int ans = Integer.parseInt(time);
		int temp = Integer.parseInt(time);
		ans = ans / 100;
		temp = temp % 100;
		if (temp == 0) {
			return 2 * ans;
		} else if (temp > 30) {
			return 2 * ans + 1;
		} else {
			return 2 * ans;
		}
	}

	public int roundUpTime(String time) {
		int ans = Integer.parseInt(time);
		int temp = Integer.parseInt(time);
		ans = ans / 100;
		temp = temp % 100;
		if (temp == 0) {
			return 2 * ans;
		}

		if (temp > 30) {
			ans = ans + 1;
			return ans * 2;
		} else {
			return ans * 2 + 1;
		}
	}

	public ArrayList<ArrayList<Task>> passListsToGUI() throws Exception {
		ArrayList<ArrayList<Task>> temp = new ArrayList<ArrayList<Task>>();
		ArrayList<Task> combinedList = new ArrayList<Task>();
		if (listType.equals("overdue")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(overdueTasks);
			updateLists();
			listType = "overdue";
			return temp;
		} else if (listType.equals("All")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(allTasks);
			updateLists();
			listType = "All";
			return temp;
		} else if (listType.equals("floating")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(floatingTasks);
			updateLists();
			listType = "floating";
			return temp;
		} else if (listType.equals("deadline")) {
			executeView(date);
			temp.add(listToTimeline);
			combinedList.addAll(overdueTasks);
			combinedList.addAll(deadlineTasks);
			temp.add(combinedList);
			listType = "deadline";
			updateLists();
			return temp;
		} else if (listType.equals("event")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(eventTasks);
			updateLists();
			listType = "event";
			return temp;
		} else if (listType.equals("done")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(doneTasks);
			updateLists();
			listType = "done";
			return temp;
		} else if (listType.equals("search")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(searchResults);
			updateLists();
			listType = "search";
			return temp;
		} else {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(listToTimeline);
			updateLists();
			return temp;
		}
	}

	public void writeToFile() throws IOException, ClassNotFoundException {
		executeUpdate();
		ArrayList<Task> temp = new ArrayList<Task>();
		temp.addAll(floatingTasks);
		temp.addAll(deadlineTasks);
		temp.addAll(eventTasks);
		temp.addAll(overdueTasks);
		temp.addAll(doneTasks);
		Sort.normal_sort(temp);
		FileStorage.clear();
		FileStorage.writeObjectAsString(temp);
	}

	public String passDate() {
		return date[1];
	}

	public String passListType() {
		return listType;
	}

	public Task passSelectedTask() {
		Task temp = selectedTask;
		selectedTask = null;
		return temp;
	}
}
```
###### .metadata\.plugins\org.eclipse.core.resources\.history\1a\d0c311a3f886001517b1b65a1f8245b9
``` 
	public void executeRedo() throws IOException, Exception {
		if (!undoneStates.isEmpty()) {
			lastStates.push(FileStorage.readStringAsString(path));
			FileStorage.clear();
			FileStorage.writeStringAsString(undoneStates.pop());
		} else {
			throw new Exception("Already at current");
		}
		updateLists();
	}

	public String[] getStringForParsing(String[] commandParts) {
		String[] stringToParse = new String[commandParts.length - 1];
		for (int i = 1; i < commandParts.length; i++) {
			stringToParse[i - 1] = commandParts[i];
		}
		stringToParse[0] = "add";
		return stringToParse;
	}

	public void addTaskToList(Task newTask) {
		switch (newTask.getTaskType()) {
		case TASKTYPE_FLOATING:
			floatingTasks.add(newTask);
			listType = "floating";
			break;
		case TASKTYPE_DEADLINE:
			this.fillUpTime(newTask);
			deadlineTasks.add(newTask);
			date[1] = newTask.getTaskEndDate();
			listType = "date";
			break;
		case TASKTYPE_EVENT:
			this.fillUpTime(newTask);
			eventTasks.add(newTask);
			date[1] = newTask.getTaskStartDate();
			listType = "date";
			break;
		}
	}

	public Task deleteTaskFromList(int deleteId) throws Exception {
		Task deletedTask = new Task();
		switch (listType) {
		case TASKTYPE_FLOATING:
			deletedTask = removeTaskFromFloatingList(deleteId);
			break;
		case TASKTYPE_DEADLINE:
			if (deleteId > overdueTasks.size()) {
				int temp = deleteId - overdueTasks.size();
				deletedTask = removeTaskFromDeadlineList(temp);
			} else {
				deletedTask = removeTaskFromOverdueList(deleteId);
			}
			break;
		case TASKTYPE_EVENT:
			deletedTask = removeTaskFromEventList(deleteId);
			break;
		case TASKTYPE_overdue:
			deletedTask = removeTaskFromOverdueList(deleteId);
			break;
		case TASKTYPE_done:
			deletedTask = removeTaskFromDoneList(deleteId);
			break;
		}
		selectedTask = deletedTask;
		return deletedTask;
	}

	public Task removeTaskFromFloatingList(int deleteId) throws Exception {
		if (floatingTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = floatingTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromDeadlineList(int deleteId) throws Exception {
		if (deadlineTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = deadlineTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromEventList(int deleteId) throws Exception {
		if (floatingTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = eventTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromOverdueList(int deleteId) throws Exception {
		if (floatingTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = overdueTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromDoneList(int deleteId) throws Exception {
		if (doneTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = doneTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	/*
	 * get what user wants to view date e.g. navigate 010101
	 */

	public void executeUpdate() throws IOException, ClassNotFoundException {
		logger.log(Level.INFO, "Executing Update");
		String currentDate = parser.getCurrentDate();
		for (int i = 0; i < deadlineTasks.size(); i++) {
			Task taskToCheck = deadlineTasks.get(i);
			String endDate = taskToCheck.getTaskEndDate();
			if (parser.endDatePassed(currentDate, endDate) && (!taskToCheck.getTaskType().equals(TASKTYPE_overdue))) {
				taskToCheck.setTaskType(TASKTYPE_overdue);
			}
		}

		for (int j = 0; j < eventTasks.size(); j++) {
			Task taskToCheck = eventTasks.get(j);
			String endDate = taskToCheck.getTaskEndDate();
			if (parser.endDatePassed(currentDate, endDate) && (!taskToCheck.getTaskType().equals(TASKTYPE_done))) {
				taskToCheck.setTaskType(TASKTYPE_done);
			}
		}
	}

	public ArrayList<Task> executeSort(ArrayList<Task> list) {
		list = Sort.normal_sort(list);
		return list;
	}

	public void saveLastState() throws Exception, IOException {
		String currentState = FileStorage.readStringAsString(path);

		if (!currentState.equals(lastState)) {
			lastStates.push(currentState);
			lastState = currentState;
			undoneStates = new Stack<String>();
		}
	}

	public void fillUpTime(Task newTask) {
		if (newTask.getTaskType().equals("floating")) {
			return;
		} else if (newTask.getTaskType().equals("event")) {
			int newStartTime = roundDownTime(newTask.getTaskStartTime());
			int newEndTime = roundUpTime(newTask.getTaskEndTime());
			for (int counter = newStartTime; counter < newEndTime; counter++) {
				newTask.setEventTime(counter);
			}
		} else {
			int newEndTime = roundDownTime(newTask.getTaskEndTime());
			newTask.setDeadlineTime(newEndTime);
		}
	}

	public int roundDownTime(String time) {
		int ans = Integer.parseInt(time);
		int temp = Integer.parseInt(time);
		ans = ans / 100;
		temp = temp % 100;
		if (temp == 0) {
			return 2 * ans;
		} else if (temp > 30) {
			return 2 * ans + 1;
		} else {
			return 2 * ans;
		}
	}

	public int roundUpTime(String time) {
		int ans = Integer.parseInt(time);
		int temp = Integer.parseInt(time);
		ans = ans / 100;
		temp = temp % 100;
		if (temp == 0) {
			return 2 * ans;
		}

		if (temp > 30) {
			ans = ans + 1;
			return ans * 2;
		} else {
			return ans * 2 + 1;
		}
	}

	public ArrayList<ArrayList<Task>> passListsToGUI() throws Exception {
		ArrayList<ArrayList<Task>> temp = new ArrayList<ArrayList<Task>>();
		ArrayList<Task> combinedList = new ArrayList<Task>();
		if (listType.equals("overdue")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(overdueTasks);
			updateLists();
			listType = "overdue";
			return temp;
		} else if (listType.equals("All")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(allTasks);
			updateLists();
			listType = "All";
			return temp;
		} else if (listType.equals("floating")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(floatingTasks);
			updateLists();
			listType = "floating";
			return temp;
		} else if (listType.equals("deadline")) {
			executeView(date);
			temp.add(listToTimeline);
			combinedList.addAll(overdueTasks);
			combinedList.addAll(deadlineTasks);
			temp.add(combinedList);
			listType = "deadline";
			updateLists();
			return temp;
		} else if (listType.equals("event")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(eventTasks);
			updateLists();
			listType = "event";
			return temp;
		} else if (listType.equals("done")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(doneTasks);
			updateLists();
			listType = "done";
			return temp;
		} else if (listType.equals("search")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(searchResults);
			updateLists();
			listType = "search";
			return temp;
		} else {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(listToTimeline);
			updateLists();
			return temp;
		}
	}

	public void writeToFile() throws IOException, ClassNotFoundException {
		executeUpdate();
		ArrayList<Task> temp = new ArrayList<Task>();
		temp.addAll(floatingTasks);
		temp.addAll(deadlineTasks);
		temp.addAll(eventTasks);
		temp.addAll(overdueTasks);
		temp.addAll(doneTasks);
		Sort.normal_sort(temp);
		FileStorage.clear();
		FileStorage.writeObjectAsString(temp);
	}

	public String passDate() {
		return date[1];
	}

	public String passListType() {
		return listType;
	}

	public Task passSelectedTask() {
		Task temp = selectedTask;
		selectedTask = null;
		return temp;
	}
}
```
###### .metadata\.plugins\org.eclipse.core.resources\.history\4\2057577ef986001517b1b65a1f8245b9
``` 
package LemonBuddy.Test;

import static org.junit.Assert.*;

import java.io.IOException;
import java.util.ArrayList;

import org.junit.Test;
import org.junit.Before;

import LemonBuddy.CommandExecutor;
import LemonBuddy.Task;

public class TestExecutor {

	CommandExecutor tester;
		
	private static final String TASKTYPE_event = "event";
	private static final String TASKTYPE_deadline = "deadline";
	private static final String TASKTYPE_overdue = "overdue";
	private static final String TASKTYPE_done = "done";
	private static final String TASKTYPE_floating = "floating";

	String lastListType;
	String listType;

	Task floatingTask1 = new Task();
	Task floatingTask2 = new Task();
	Task floatingTask3 = new Task();

	Task deadlineTask1 = new Task();
	Task deadlineTask2 = new Task();
	Task deadlineTask3 = new Task();
	Task deadlineTask4 = new Task();

	Task eventTask1 = new Task();
	Task eventTask2 = new Task();
	Task eventTask3 = new Task();
	Task eventTask4 = new Task();

	ArrayList<Task> floatingTasks = new ArrayList<Task>();
	ArrayList<Task> deadlineTasks = new ArrayList<Task>();
	ArrayList<Task> eventTasks = new ArrayList<Task>();
	ArrayList<Task> overdueTasks = new ArrayList<Task>();
	ArrayList<Task> doneTasks = new ArrayList<Task>();
	ArrayList<Task> allTasks = new ArrayList<Task>();

	@Before
	public void setUp() throws Exception {

		tester = new CommandExecutor();

		floatingTask1.setTaskName("paint a cat");
		floatingTask1.setTaskType("floating");
		floatingTask2.setTaskName("paint a dog");
		floatingTask2.setTaskType("floating");
		floatingTask3.setTaskName("paint a giraffe");
		floatingTask3.setTaskType("floating");
		floatingTask3.setTaskPriority("low");

		deadlineTask1.setTaskName("do PC1432");
		deadlineTask1.setTaskType("deadline");
		deadlineTask1.setTaskEndDate("221215");
		deadlineTask1.setTaskEndTime("1310");
		deadlineTask1.setTaskPriority("medium");

		deadlineTask2.setTaskName("finish knitting project");
		deadlineTask2.setTaskType("deadline");
		deadlineTask2.setTaskEndDate("291115");
		deadlineTask2.setTaskEndTime("1200");

		deadlineTask3.setTaskName("finish strawberries");
		deadlineTask3.setTaskType("deadline");
		deadlineTask3.setTaskEndDate("151115");
		deadlineTask3.setTaskEndTime("1900");
		deadlineTask3.setTaskDescription("dont let them turn mouldy");

		deadlineTask4.setTaskName("do PC1431");
		deadlineTask4.setTaskType("deadline");
		deadlineTask4.setTaskEndDate("221215");
		deadlineTask4.setTaskEndTime("1300");
		deadlineTask4.setTaskPriority("high");

		eventTask1.setTaskName("chalet with cats");
		eventTask1.setTaskType("event");
		eventTask1.setTaskStartDate("101215");
		eventTask1.setTaskEndDate("221215");
		eventTask1.setTaskStartTime("0800");
		eventTask1.setTaskEndTime("2200");
		eventTask1.setTaskDescription("bring party biscuits!");
		eventTask1.setTaskPriority("high");

		eventTask2.setTaskName("water plants when granny is overseas");
		eventTask2.setTaskType("event");
		eventTask2.setTaskStartDate("101215");
		eventTask2.setTaskEndDate("151215");
		eventTask2.setTaskStartTime("0000");
		eventTask2.setTaskEndTime("2359");
		eventTask2.setTaskPriority("medium");

		eventTask3.setTaskName("a levels");
		eventTask3.setTaskType("event");
		eventTask3.setTaskStartDate("011115");
		eventTask3.setTaskEndDate("251115");
		eventTask3.setTaskStartTime("0000");
		eventTask3.setTaskEndTime("2359");
		eventTask3.setTaskDescription("last lap!");
		eventTask3.setTaskPriority("high");

		eventTask4.setTaskName("sister's o levels");
		eventTask4.setTaskType("event");
		eventTask4.setTaskStartDate("011115");
		eventTask4.setTaskEndDate("101115");
		eventTask4.setTaskStartTime("0000");
		eventTask4.setTaskEndTime("2359");
		eventTask4.setTaskDescription("last lap!");
		eventTask4.setTaskPriority("high");

		floatingTasks.add(floatingTask1);
		floatingTasks.add(floatingTask2);
		floatingTasks.add(floatingTask3);

		deadlineTasks.add(deadlineTask1);
		deadlineTasks.add(deadlineTask2);
		deadlineTasks.add(deadlineTask3);
		deadlineTasks.add(deadlineTask4);

		eventTasks.add(eventTask1);
		eventTasks.add(eventTask2);
		eventTasks.add(eventTask3);
		eventTasks.add(eventTask4);

		allTasks.add(deadlineTask1);
		allTasks.add(deadlineTask2);
		allTasks.add(deadlineTask3);
		allTasks.add(deadlineTask4);
		allTasks.add(eventTask1);
		allTasks.add(eventTask2);
		allTasks.add(eventTask3);
		allTasks.add(eventTask4);
		allTasks.add(floatingTask1);
		allTasks.add(floatingTask2);
		allTasks.add(floatingTask3);
		
		overdueTasks.add(deadlineTask1);
		overdueTasks.add(deadlineTask2);
		doneTasks.add(deadlineTask1);
		doneTasks.add(deadlineTask2);
	}

	@Test
	public void testStringForParsingForEdit() throws ClassNotFoundException, IOException {

		String input = "edit 1 buy bed by 291215";
		String[] commandParts = input.split(" ");
		String[] expectedParts = { "add", "buy", "bed", "by", "291215" };

		assertArrayEquals("edits the input to help add a new task to merge with the old one", expectedParts,
				tester.getStringForParsing(commandParts));
	}

	@Test
	public void testAddTaskToList() throws ClassNotFoundException, IOException {

		Task newTask = new Task();

		newTask.setTaskType("floating");
		tester.addTaskToList(newTask);

		newTask.setTaskStartTime("1040");
		newTask.setTaskEndTime("1150");

		newTask.setTaskType("deadline");
		tester.addTaskToList(newTask);

		// Also testing fillUpTime(Task), roundDownTime(String),
		// roundUpTime(String);

		newTask.setTaskStartTime("0050");
		newTask.setTaskEndTime("0059");

		newTask.setTaskType("event");
		tester.addTaskToList(newTask);

		newTask.setTaskStartTime("0000");
		newTask.setTaskEndTime("0020");

		newTask.setTaskType("event");
		tester.addTaskToList(newTask);

		newTask.setTaskStartTime("1230");
		newTask.setTaskEndTime("1400");

		newTask.setTaskType("event");
		tester.addTaskToList(newTask);

	}

	@Test
	public void testDeleteTaskFromList() throws Exception {
		
		int deleteID = 1;
		
		Task taskToDelete = new Task();
		taskToDelete.setTaskType("floating");
		listType = TASKTYPE_floating;
		tester.addTaskToList(taskToDelete);
		
		assertEquals("deleting first floating task", taskToDelete ,tester.deleteTaskFromList(deleteID));

	}
	
	@Test
	public void testDeleteTaskFromList2() throws Exception {
		
		int deleteID = 1;
		
		Task taskToDelete = new Task();
		taskToDelete.setTaskType("event");
		listType = TASKTYPE_event;
		tester.addTaskToList(taskToDelete);
		
		assertEquals("deleting first deadline task", taskToDelete ,tester.deleteTaskFromList(deleteID));

	}

	@Test
	public void testRemoveTaskFromFloatingList() throws Exception {
		int deleteID = 1;
		Task floatingTask = new Task();
		floatingTask.setTaskType("floating");
		tester.addTaskToList(floatingTask);
		
		assertEquals("deleting first floating task", floatingTask, tester.removeTaskFromFloatingList(deleteID));
	}
	
	@Test
	public void testRemoveTaskFromDeadlineList() throws Exception {
		int deleteID = 1;
		Task deadlineTask = new Task();
		deadlineTask.setTaskType("deadline");
		tester.addTaskToList(deadlineTask);
		
		assertEquals("deleting first deadline task", deadlineTask, tester.removeTaskFromDeadlineList(deleteID));
	}
	
	@Test
	public void testRemoveTaskFromEventList() throws Exception {
		int deleteID = 1;
		Task eventTask = new Task();
		eventTask.setTaskType("event");
		tester.addTaskToList(eventTask);
		
		assertEquals("deleting first event task", eventTask, tester.removeTaskFromEventList(deleteID));
	}
	
	@Test
	public void testRemoveTaskFromOverdueList() throws Exception {
		int deleteID = 1;
		Task overdueTask = new Task();
		overdueTask.setTaskType("overdue");
		overdueTask.setTaskIsOverdue();
		tester.addTaskToList(overdueTask);
		
		assertEquals("deleting first overdue task", overdueTask, tester.removeTaskFromOverdueList(deleteID));
	}
	
	@Test
	public void testRemoveTaskFromDoneList() throws Exception {
		int deleteID = 1;
		Task doneTask = new Task();
		doneTask.setTaskType("done");
		doneTask.setTaskIsDone();
		tester.addTaskToList(doneTask);
		
		assertEquals("deleting first done task", doneTask, tester.removeTaskFromDoneList(deleteID));
	}

	@Test
	public void testSort() {

		ArrayList<Task> expectedDeadlineSort = new ArrayList<Task>();
		expectedDeadlineSort.add(deadlineTask3);
		expectedDeadlineSort.add(deadlineTask2);
		expectedDeadlineSort.add(deadlineTask4);
		expectedDeadlineSort.add(deadlineTask1);

		assertEquals("test correct task is deleted", expectedDeadlineSort, tester.executeSort(deadlineTasks));

		ArrayList<Task> expectedEventSort = new ArrayList<Task>();
		expectedEventSort.add(eventTask3);
		expectedEventSort.add(eventTask4);
		expectedEventSort.add(eventTask1);
		expectedEventSort.add(eventTask2);

		assertEquals("test correct task is deleted", expectedEventSort, tester.executeSort(eventTasks));

		ArrayList<Task> expectedFloatingSort = new ArrayList<Task>();
		expectedFloatingSort.add(floatingTask1);
		expectedFloatingSort.add(floatingTask2);
		expectedFloatingSort.add(floatingTask3);

		assertEquals("test correct task is deleted", expectedFloatingSort, tester.executeSort(floatingTasks));

		ArrayList<Task> expectedSort = new ArrayList<Task>();
		expectedSort.add(eventTask3);
		expectedSort.add(eventTask4);
		expectedSort.add(deadlineTask3);
		expectedSort.add(deadlineTask2);
		expectedSort.add(eventTask1);
		expectedSort.add(eventTask2);
		expectedSort.add(deadlineTask4);
		expectedSort.add(deadlineTask1);
		expectedSort.add(floatingTask1);
		expectedSort.add(floatingTask2);
		expectedSort.add(floatingTask3);

		assertEquals("test correct task is deleted", expectedSort, tester.executeSort(allTasks));
	}
}
```
###### .metadata\.plugins\org.eclipse.core.resources\.history\6f\90d1f76bf986001517b1b65a1f8245b9
``` 
	public void executeRedo() throws IOException, Exception {
		if (!undoneStates.isEmpty()) {
			lastStates.push(FileStorage.readStringAsString(path));
			FileStorage.clear();
			FileStorage.writeStringAsString(undoneStates.pop());
		} else {
			throw new Exception("Already at current");
		}
		updateLists();
	}

	public String[] getStringForParsing(String[] commandParts) {
		String[] stringToParse = new String[commandParts.length - 1];
		for (int i = 1; i < commandParts.length; i++) {
			stringToParse[i - 1] = commandParts[i];
		}
		stringToParse[0] = "add";
		return stringToParse;
	}

	public void addTaskToList(Task newTask) {
		switch (newTask.getTaskType()) {
		case TASKTYPE_FLOATING:
			floatingTasks.add(newTask);
			listType = "floating";
			break;
		case TASKTYPE_DEADLINE:
			this.fillUpTime(newTask);
			deadlineTasks.add(newTask);
			date[1] = newTask.getTaskEndDate();
			listType = "date";
			break;
		case TASKTYPE_EVENT:
			this.fillUpTime(newTask);
			eventTasks.add(newTask);
			date[1] = newTask.getTaskStartDate();
			listType = "date";
			break;
		}
	}

	public Task deleteTaskFromList(int deleteId) throws Exception {
		Task deletedTask = new Task();
		switch (listType) {
		case TASKTYPE_FLOATING:
			deletedTask = removeTaskFromFloatingList(deleteId);
			break;
		case TASKTYPE_DEADLINE:
			if (deleteId > overdueTasks.size()) {
				int temp = deleteId - overdueTasks.size();
				deletedTask = removeTaskFromDeadlineList(temp);
			} else {
				deletedTask = removeTaskFromOverdueList(deleteId);
			}
			break;
		case TASKTYPE_EVENT:
			deletedTask = removeTaskFromEventList(deleteId);
			break;
		case TASKTYPE_overdue:
			deletedTask = removeTaskFromOverdueList(deleteId);
			break;
		case TASKTYPE_done:
			deletedTask = removeTaskFromDoneList(deleteId);
			break;
		}
		selectedTask = deletedTask;
		return deletedTask;
	}

	public Task removeTaskFromFloatingList(int deleteId) throws Exception {
		if (floatingTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = floatingTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromDeadlineList(int deleteId) throws Exception {
		if (deadlineTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = deadlineTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromEventList(int deleteId) throws Exception {
		if (floatingTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = eventTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromOverdueList(int deleteId) throws Exception {
		if (floatingTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = overdueTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromDoneList(int deleteId) throws Exception {
		if (doneTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = doneTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	/*
	 * get what user wants to view date e.g. navigate 010101
	 */

	public void executeUpdate() throws IOException, ClassNotFoundException {
		logger.log(Level.INFO, "Executing Update");
		String currentDate = parser.getCurrentDate();
		for (int i = 0; i < deadlineTasks.size(); i++) {
			Task taskToCheck = deadlineTasks.get(i);
			String endDate = taskToCheck.getTaskEndDate();
			if (parser.endDatePassed(currentDate, endDate) && (!taskToCheck.getTaskType().equals(TASKTYPE_overdue))) {
				taskToCheck.setTaskType(TASKTYPE_overdue);
			}
		}

		for (int j = 0; j < eventTasks.size(); j++) {
			Task taskToCheck = eventTasks.get(j);
			String endDate = taskToCheck.getTaskEndDate();
			if (parser.endDatePassed(currentDate, endDate) && (!taskToCheck.getTaskType().equals(TASKTYPE_done))) {
				taskToCheck.setTaskType(TASKTYPE_done);
			}
		}
	}

	public ArrayList<Task> executeSort(ArrayList<Task> list) {
		list = Sort.normal_sort(list);
		return list;
	}

	public void saveLastState() throws Exception, IOException {
		String currentState = FileStorage.readStringAsString(path);

		if (!currentState.equals(lastState)) {
			lastStates.push(currentState);
			lastState = currentState;
			undoneStates = new Stack<String>();
		}
	}
```
###### main\src\LemonBuddy\CommandController.java
``` java
	private static void executeSaveLastState(String commandType) throws Exception, IOException {
		if (commandType.equals(COMMAND_ADD) || commandType.equals(COMMAND_DELETE) || commandType.equals(COMMAND_EDIT)
				|| commandType.equals(COMMAND_DONE)) {
			commandexecutor.saveLastState();
		}
	}

	public String[] splitCommand(String command) {
		String[] commandParts = command.split(" ");
		return commandParts;
	}

	private boolean isValidTaskType(String taskType) {
		if (taskType.equals(TASKTYPE_FLOATING) || taskType.equals(TASKTYPE_DEADLINE)
				|| taskType.equals(TASKTYPE_EVENT)) {
			return true;
		} else
			return false;
	}

	public ArrayList<ArrayList<Task>> passListsToGUI() throws Exception {
		return commandexecutor.passListsToGUI();
	}

	public String getDate() {
		return commandexecutor.passDate();
	}

	public String getListType() {
		return commandexecutor.passListType();
	}

	public String getNotificationMessage() {
		String temp = errorMessage;
		errorMessage = "";
		return temp;
	}

	public boolean checkForSuccessfulCommand() {
		return isSuccesful;
	}

	public String passCommand() {
		return commandType;
	}

	public Task getSelectedTask() {
		return commandexecutor.passSelectedTask();
	}
}
```
###### main\src\LemonBuddy\CommandExecutor.java
``` java
	public void executeRedo() throws IOException, Exception {
		if (!undoneStates.isEmpty()) {
			lastStates.push(FileStorage.readStringAsString(path));
			FileStorage.clear();
			FileStorage.writeStringAsString(undoneStates.pop());
		} else {
			throw new Exception("Already at current");
		}
		updateLists();
	}

	public String[] getStringForParsing(String[] commandParts) {
		String[] stringToParse = new String[commandParts.length - 1];
		for (int i = 1; i < commandParts.length; i++) {
			stringToParse[i - 1] = commandParts[i];
		}
		stringToParse[0] = "add";
		return stringToParse;
	}

	public void addTaskToList(Task newTask) {
		switch (newTask.getTaskType()) {
		case TASKTYPE_FLOATING:
			floatingTasks.add(newTask);
			listType = "floating";
			break;
		case TASKTYPE_DEADLINE:
			this.fillUpTime(newTask);
			deadlineTasks.add(newTask);
			date[1] = newTask.getTaskEndDate();
			listType = "date";
			break;
		case TASKTYPE_EVENT:
			this.fillUpTime(newTask);
			eventTasks.add(newTask);
			date[1] = newTask.getTaskStartDate();
			listType = "date";
			break;
		}
	}

	public Task deleteTaskFromList(int deleteId) throws Exception {
		Task deletedTask = new Task();
		switch (listType) {
		case TASKTYPE_FLOATING:
			deletedTask = removeTaskFromFloatingList(deleteId);
			break;
		case TASKTYPE_DEADLINE:
			if (deleteId > overdueTasks.size()) {
				int temp = deleteId - overdueTasks.size();
				deletedTask = removeTaskFromDeadlineList(temp);
			} else {
				deletedTask = removeTaskFromOverdueList(deleteId);
			}
			break;
		case TASKTYPE_EVENT:
			deletedTask = removeTaskFromEventList(deleteId);
			break;
		case TASKTYPE_overdue:
			deletedTask = removeTaskFromOverdueList(deleteId);
			break;
		case TASKTYPE_done:
			deletedTask = removeTaskFromDoneList(deleteId);
			break;
		}
		selectedTask = deletedTask;
		return deletedTask;
	}

	public Task removeTaskFromFloatingList(int deleteId) throws Exception {
		if (floatingTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = floatingTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromDeadlineList(int deleteId) throws Exception {
		if (deadlineTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = deadlineTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromEventList(int deleteId) throws Exception {
		if (floatingTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = eventTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromOverdueList(int deleteId) throws Exception {
		if (floatingTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = overdueTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	public Task removeTaskFromDoneList(int deleteId) throws Exception {
		if (doneTasks.size() < deleteId) {
			throw new Exception("Invalid Index");
		}
		Task taskToDelete = doneTasks.remove(deleteId - 1);
		return taskToDelete;
	}

	/*
	 * get what user wants to view date e.g. navigate 010101
	 */

	public void executeUpdate() throws IOException, ClassNotFoundException {
		logger.log(Level.INFO, "Executing Update");
		String currentDate = parser.getCurrentDate();
		for (int i = 0; i < deadlineTasks.size(); i++) {
			Task taskToCheck = deadlineTasks.get(i);
			String endDate = taskToCheck.getTaskEndDate();
			if (parser.endDatePassed(currentDate, endDate) && (!taskToCheck.getTaskType().equals(TASKTYPE_overdue))) {
				taskToCheck.setTaskType(TASKTYPE_overdue);
			}
		}

		for (int j = 0; j < eventTasks.size(); j++) {
			Task taskToCheck = eventTasks.get(j);
			String endDate = taskToCheck.getTaskEndDate();
			if (parser.endDatePassed(currentDate, endDate) && (!taskToCheck.getTaskType().equals(TASKTYPE_done))) {
				taskToCheck.setTaskType(TASKTYPE_done);
			}
		}
	}

	public ArrayList<Task> executeSort(ArrayList<Task> list) {
		list = Sort.normal_sort(list);
		return list;
	}

	public void saveLastState() throws Exception, IOException {
		String currentState = FileStorage.readStringAsString(path);

		if (!currentState.equals(lastState)) {
			lastStates.push(currentState);
			lastState = currentState;
			undoneStates = new Stack<String>();
		}
	}
	
	public void fillUpTime(Task newTask) {
		if (newTask.getTaskType().equals("floating")) {
			return;
		} else if (newTask.getTaskType().equals("event")) {
			int newStartTime = roundDownTime(newTask.getTaskStartTime());
			int newEndTime = roundUpTime(newTask.getTaskEndTime());
			for (int counter = newStartTime; counter < newEndTime; counter++) {
				newTask.setEventTime(counter);
			}
		} else {
			int newEndTime = roundDownTime(newTask.getTaskEndTime());
			newTask.setDeadlineTime(newEndTime);
		}
	}

	public int roundDownTime(String time) {
		int ans = Integer.parseInt(time);
		int temp = Integer.parseInt(time);
		ans = ans / 100;
		temp = temp % 100;
		if (temp == 0) {
			return 2 * ans;
		} else if (temp > 30) {
			return 2 * ans + 1;
		} else {
			return 2 * ans;
		}
	}

	public int roundUpTime(String time) {
		int ans = Integer.parseInt(time);
		int temp = Integer.parseInt(time);
		ans = ans / 100;
		temp = temp % 100;
		if (temp == 0) {
			return 2 * ans;
		}

		if (temp > 30) {
			ans = ans + 1;
			return ans * 2;
		} else {
			return ans * 2 + 1;
		}
	}

	public ArrayList<ArrayList<Task>> passListsToGUI() throws Exception {
		ArrayList<ArrayList<Task>> temp = new ArrayList<ArrayList<Task>>();
		ArrayList<Task> combinedList = new ArrayList<Task>();
		if (listType.equals("overdue")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(overdueTasks);
			updateLists();
			listType = "overdue";
			return temp;
		} else if (listType.equals("All")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(allTasks);
			updateLists();
			listType = "All";
			return temp;
		} else if (listType.equals("floating")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(floatingTasks);
			updateLists();
			listType = "floating";
			return temp;
		} else if (listType.equals("deadline")) {
			executeView(date);
			temp.add(listToTimeline);
			combinedList.addAll(overdueTasks);
			combinedList.addAll(deadlineTasks);
			temp.add(combinedList);
			listType = "deadline";
			updateLists();
			return temp;
		} else if (listType.equals("event")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(eventTasks);
			updateLists();
			listType = "event";
			return temp;
		} else if (listType.equals("done")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(doneTasks);
			updateLists();
			listType = "done";
			return temp;
		} else if (listType.equals("search")) {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(searchResults);
			updateLists();
			listType = "search";
			return temp;
		} else {
			executeView(date);
			temp.add(listToTimeline);
			temp.add(listToTimeline);
			updateLists();
			return temp;
		}
	}

	public void writeToFile() throws IOException, ClassNotFoundException {
		executeUpdate();
		ArrayList<Task> temp = new ArrayList<Task>();
		temp.addAll(floatingTasks);
		temp.addAll(deadlineTasks);
		temp.addAll(eventTasks);
		temp.addAll(overdueTasks);
		temp.addAll(doneTasks);
		Sort.normal_sort(temp);
		FileStorage.clear();
		FileStorage.writeObjectAsString(temp);
	}

	public String passDate() {
		return date[1];
	}

	public String passListType() {
		return listType;
	}

	public Task passSelectedTask() {
		Task temp = selectedTask;
		selectedTask = null;
		return temp;
	}
}
```
###### main\src\LemonBuddy\Parser.java
``` java
	private void detectFromToFormat(String[] commandParts) throws Exception {
		Boolean from = false;
		Boolean to = false;
		for (String part : commandParts) {
			if (part.contains(KEYWORD_FROM)) {
				from = true;
			}
		}
		for (String part : commandParts) {
			if (part.contains(KEYWORD_TO)) {
				to = true;
			}
		}
		if (from) {
			if (!to) {
				throw new Exception("Missing \"to\" from command");
			}
		}
	}

	private void setDeadlineDefaultTime(Task newTask) {
		if (newTask.getTaskType().equals(TASKTYPE_DEADLINE)) {
			if (newTask.taskStartDateIsEmpty() && newTask.taskEndDateIsEmpty()) {
				newTask.setTaskEndDate(getCurrentDate());
			}
			if (newTask.taskStartTimeIsEmpty() && newTask.taskEndTimeIsEmpty()) {
				newTask.setTaskEndTime(getCurrentTime());
			}
		}
	}

	private void setFromToDefaultTime(Task newTask) {
		if (newTask.getTaskType().equals(TASKTYPE_EVENT)) {
			if (newTask.taskStartDateIsEmpty() && newTask.taskEndDateIsEmpty()) {
				newTask.setTaskStartDate(getCurrentDate());
				newTask.setTaskEndDate(getCurrentDate());
			}
			if (newTask.taskStartDateIsEmpty() && !newTask.taskEndDateIsEmpty()) {
				newTask.setTaskStartDate(newTask.getTaskEndDate());
			}
			if (!newTask.taskStartDateIsEmpty() && newTask.taskEndDateIsEmpty()) {
				newTask.setTaskEndDate(newTask.getTaskStartDate());
			}
			if (newTask.taskStartTimeIsEmpty() && newTask.taskEndTimeIsEmpty()) {
				newTask.setTaskStartTime("0000");
				newTask.setTaskEndTime("2359");
			}
			if (newTask.taskStartTimeIsEmpty() && !newTask.taskEndTimeIsEmpty()) {
				newTask.setTaskStartTime(newTask.getTaskEndTime());
			}
			if (!newTask.taskStartTimeIsEmpty() && newTask.taskEndTimeIsEmpty()) {
				newTask.setTaskEndTime(newTask.getTaskStartTime());
			}
		}
	}

	private String removeSlashes(String date) {
		date = date.replaceAll("/", "");
		return date;
	}

	private String addOneDay(String date, String time) {
		Calendar initialTime = Calendar.getInstance();
		SimpleDateFormat dateFormatter = new SimpleDateFormat(SIMPLEDATETIMEFORMAT);
		time = getCurrentTime();
		initialTime.set(Integer.parseInt(date.substring(4, 6)), Integer.parseInt(date.substring(2, 4)) - 1,
				Integer.parseInt(date.substring(0, 2)), Integer.parseInt(time.substring(0, 2)),
				Integer.parseInt(time.substring(2, 4)), 0);
		initialTime.add(Calendar.HOUR, 24);
		String[] timeInfo = dateFormatter.format(initialTime.getTime()).split(" ");
		return timeInfo[0];

	}

	private String[] addOneHour(String date, String time) {
		Calendar initialTime = Calendar.getInstance();
		initialTime.set(Integer.parseInt(date.substring(4, 6)), Integer.parseInt(date.substring(2, 4)) - 1,
				Integer.parseInt(date.substring(0, 2)), Integer.parseInt(time.substring(0, 2)),
				Integer.parseInt(time.substring(2, 4)), 0);
		initialTime.add(Calendar.HOUR, 1);
		SimpleDateFormat dateFormatter = new SimpleDateFormat(SIMPLEDATETIMEFORMAT);
		String[] timeInfo = dateFormatter.format(initialTime.getTime()).split(" ");
		return timeInfo;
	}

	public String getCurrentDate() {
		DateFormat df = new SimpleDateFormat(DATETIMEFORMAT);
		Date dateobj = new Date();
		String currentDate = df.format(dateobj);
		return currentDate;
	}

	public String getCurrentTime() {
		DateFormat df = new SimpleDateFormat("HHmm");
		Calendar calobj = Calendar.getInstance();
		String time = df.format(calobj.getTime());
		return time;
	}

	// 0 for date 1 for time
	private String[] getTimeInfo(String[] commandParts, Task newTask, int wordIndex) throws Exception {
		logger.log(Level.INFO, "Parsing time");
		String[] timeInfo = new String[2];
		timeInfo[0] = "-1";
		timeInfo[1] = "-1";

		String currentDate = getCurrentDate();
		String currentTime = getCurrentTime();
		String taskOn = commandParts[wordIndex];
		// trim and comma is present
		if (commandParts[wordIndex].contains(",")) {
			if (!(commandParts[wordIndex].indexOf(",") == commandParts[wordIndex].length() - 1)) {
				throw new Exception("Comma has no spacing");
			}
		}

		int parseCount = 1;
		for (int i = 0; i < parseCount; i++) {
			taskOn = commandParts[wordIndex];
			if (commandParts[wordIndex].contains(",")) {
				taskOn = commandParts[wordIndex].substring(0, commandParts[wordIndex].indexOf(","));
				parseCount = 2;
			}
			taskOn = removeSlashes(taskOn);
			if (!(taskOn.matches("[0-9]+") && ((taskOn.length() == 4) || (taskOn.length() == 6))
					|| (taskOn.equals(KEYWORD_TOMORROW)))) {
				throw new Exception("Invalid date/time format");
			}
			if (taskOn.length() == 4) {
				int taskOnInt = Integer.valueOf(taskOn);
				if (taskOnInt >= 2400 || taskOnInt < 0) {
					throw new Exception("Time out of range");
				}
				timeInfo[1] = taskOn;
			} else if (taskOn.length() == 6) {
				if (!isDateValid(taskOn)) {
					throw new Exception("Invalid Date");
				}
				timeInfo[0] = taskOn;
			} else if (taskOn.equals(KEYWORD_TOMORROW)) {
				String nextDate = addOneDay(currentDate, currentTime);
				timeInfo[0] = nextDate;
			}
			wordIndex++;
		}

		return timeInfo;
	}

	public boolean endDatePassed(String currentDate, String endDate) {

		int currentDay = parseInt(getDay(currentDate));
		int currentMonth = parseInt(getMonth(currentDate));
		int currentYear = parseInt(getYear(currentDate));
		int endDay = parseInt(getDay(endDate));
		int endMonth = parseInt(getMonth(endDate));
		int endYear = parseInt(getYear(endDate));

		if ((currentYear > endYear)) {
			return true;
		} else if ((currentMonth > endMonth) && (currentYear == endYear)) {
			return true;
		} else if ((currentDay > endDay) && (currentMonth == endMonth) && (currentYear == endYear)) {
			return true;
		} else {
			return false;
		}
	}

	public String getDay(String date) {
		return date.substring(0, 2);
	}

	public String getMonth(String date) {
		return date.substring(2, 4);
	}

	public String getYear(String date) {
		return date.substring(4, 6);
	}

	protected int parseInt(String str) {
		int i = 0;
		int num = 0;
		boolean isNeg = false;

		// Check for negative sign; if it's there, set the isNeg flag
		if (str.charAt(0) == '-') {
			isNeg = true;
			i = 1;
		}

		// Process each character of the string;
		while (i < str.length()) {
			num *= 10;
			num += str.charAt(i++) - '0'; // Minus the ASCII code of '0' to get
											// the value of the charAt(i++).
		}

		if (isNeg)
			num = -num;
		return num;
	}

	public static boolean isDateValid(String date) {
		try {
			DateFormat df = new SimpleDateFormat(DATETIMEFORMAT);
			df.setLenient(false);
			df.parse(date);
			return true;
		} catch (ParseException e) {
			return false;
		}
	}
}
```
###### main\src\LemonBuddy\Task.java
``` java
	public void setEventTime(int time) {
		SimpleStringProperty temp = new SimpleStringProperty("1");
		this.displayTimmings[time] = temp;
	}
	
	public void setDeadlineTime(int time) {
		SimpleStringProperty temp = new SimpleStringProperty("-1");
		this.displayTimmings[time] = temp;
	}

	//RETRIEVERS//
	
	public String getTaskName() {
		StringBuffer buffer = new StringBuffer(this.taskName);
		return buffer.toString();
	}

	public String getTaskType() {
		StringBuffer buffer = new StringBuffer(this.taskType);
		return buffer.toString();
	}

	public Boolean getTaskIsDone() {
		return this.taskIsDone;

	}

	public Boolean getTaskIsOverdue() {
		return this.taskIsOverdue;
	}

	public Boolean getTaskIsNewest() {
		return this.taskIsNewest;
	}

	public String getTaskStartDate() {
		return this.taskStartDate;
	}

	public Boolean taskStartDateIsEmpty() {
		if (this.taskStartDate == "-1") {
			return true;
		} else {
			return false;
		}
	}

	public String getTaskEndDate() {
		return this.taskEndDate;
	}

	public Boolean taskEndDateIsEmpty() {
		if (this.taskEndDate == "-1") {
			return true;
		} else {
			return false;
		}
	}

	public String getTaskStartTime() {
		return this.taskStartTime;
	}
	
	public Boolean taskStartTimeIsEmpty(){
		if (this.taskStartTime == "-1") {
			return true;
		} else {
			return false;
		}
	}
	
	public String getTaskEndTime() {
		return this.taskEndTime;
	}

	public Boolean taskEndTimeIsEmpty(){
		if (this.taskEndTime == "-1") {
			return true;
		} else {
			return false;
		}
	}
	
	public String getTaskPriority() {
		StringBuffer buffer = new StringBuffer(this.taskPriority);
		return buffer.toString();
	}

	public String getTaskDescription() {
		StringBuffer buffer = new StringBuffer(this.taskDescription);
		return buffer.toString();
	}

	public SimpleStringProperty getDisplayName() {
		return this.displayName;
	}
	
	public SimpleStringProperty getDisplayStartDate() {
		return this.displayStartDate;
	}
	
	public SimpleStringProperty getDisplayEndDate() {
		return this.displayEndDate;
	}
	
	public SimpleStringProperty getDisplayStartTime() {
		return this.displayStartTime;
	}
	
	public SimpleStringProperty getDisplayEndTime() {
		return this.displayEndTime;
	}
	
	public SimpleStringProperty getDisplayPriority() {
		return this.displayPriority;
	}
	
	public SimpleStringProperty getDisplayDescription() {
		return this.displayDescription;
	}

	public SimpleStringProperty getDisplayId() {
		return this.displayId;
	}
	
	public SimpleStringProperty getTimmings(int num) {
		return this.displayTimmings[num];
	}

}
```
###### main\src\LemonBuddy\Test\TestExecutor.java
``` java
package LemonBuddy.Test;

import static org.junit.Assert.*;

import java.io.IOException;
import java.util.ArrayList;

import org.junit.Test;
import org.junit.Before;

import LemonBuddy.CommandExecutor;
import LemonBuddy.Task;

public class TestExecutor {

	CommandExecutor tester;
		
	private static final String TASKTYPE_event = "event";
	private static final String TASKTYPE_deadline = "deadline";
	private static final String TASKTYPE_overdue = "overdue";
	private static final String TASKTYPE_done = "done";
	private static final String TASKTYPE_floating = "floating";

	String lastListType;
	String listType;

	Task floatingTask1 = new Task();
	Task floatingTask2 = new Task();
	Task floatingTask3 = new Task();

	Task deadlineTask1 = new Task();
	Task deadlineTask2 = new Task();
	Task deadlineTask3 = new Task();
	Task deadlineTask4 = new Task();

	Task eventTask1 = new Task();
	Task eventTask2 = new Task();
	Task eventTask3 = new Task();
	Task eventTask4 = new Task();

	ArrayList<Task> floatingTasks = new ArrayList<Task>();
	ArrayList<Task> deadlineTasks = new ArrayList<Task>();
	ArrayList<Task> eventTasks = new ArrayList<Task>();
	ArrayList<Task> overdueTasks = new ArrayList<Task>();
	ArrayList<Task> doneTasks = new ArrayList<Task>();
	ArrayList<Task> allTasks = new ArrayList<Task>();

	@Before
	public void setUp() throws Exception {

		tester = new CommandExecutor();

		floatingTask1.setTaskName("paint a cat");
		floatingTask1.setTaskType("floating");
		floatingTask2.setTaskName("paint a dog");
		floatingTask2.setTaskType("floating");
		floatingTask3.setTaskName("paint a giraffe");
		floatingTask3.setTaskType("floating");
		floatingTask3.setTaskPriority("low");

		deadlineTask1.setTaskName("do PC1432");
		deadlineTask1.setTaskType("deadline");
		deadlineTask1.setTaskEndDate("221215");
		deadlineTask1.setTaskEndTime("1310");
		deadlineTask1.setTaskPriority("medium");

		deadlineTask2.setTaskName("finish knitting project");
		deadlineTask2.setTaskType("deadline");
		deadlineTask2.setTaskEndDate("291115");
		deadlineTask2.setTaskEndTime("1200");

		deadlineTask3.setTaskName("finish strawberries");
		deadlineTask3.setTaskType("deadline");
		deadlineTask3.setTaskEndDate("151115");
		deadlineTask3.setTaskEndTime("1900");
		deadlineTask3.setTaskDescription("dont let them turn mouldy");

		deadlineTask4.setTaskName("do PC1431");
		deadlineTask4.setTaskType("deadline");
		deadlineTask4.setTaskEndDate("221215");
		deadlineTask4.setTaskEndTime("1300");
		deadlineTask4.setTaskPriority("high");

		eventTask1.setTaskName("chalet with cats");
		eventTask1.setTaskType("event");
		eventTask1.setTaskStartDate("101215");
		eventTask1.setTaskEndDate("221215");
		eventTask1.setTaskStartTime("0800");
		eventTask1.setTaskEndTime("2200");
		eventTask1.setTaskDescription("bring party biscuits!");
		eventTask1.setTaskPriority("high");

		eventTask2.setTaskName("water plants when granny is overseas");
		eventTask2.setTaskType("event");
		eventTask2.setTaskStartDate("101215");
		eventTask2.setTaskEndDate("151215");
		eventTask2.setTaskStartTime("0000");
		eventTask2.setTaskEndTime("2359");
		eventTask2.setTaskPriority("medium");

		eventTask3.setTaskName("a levels");
		eventTask3.setTaskType("event");
		eventTask3.setTaskStartDate("011115");
		eventTask3.setTaskEndDate("251115");
		eventTask3.setTaskStartTime("0000");
		eventTask3.setTaskEndTime("2359");
		eventTask3.setTaskDescription("last lap!");
		eventTask3.setTaskPriority("high");

		eventTask4.setTaskName("sister's o levels");
		eventTask4.setTaskType("event");
		eventTask4.setTaskStartDate("011115");
		eventTask4.setTaskEndDate("101115");
		eventTask4.setTaskStartTime("0000");
		eventTask4.setTaskEndTime("2359");
		eventTask4.setTaskDescription("last lap!");
		eventTask4.setTaskPriority("high");

		floatingTasks.add(floatingTask1);
		floatingTasks.add(floatingTask2);
		floatingTasks.add(floatingTask3);

		deadlineTasks.add(deadlineTask1);
		deadlineTasks.add(deadlineTask2);
		deadlineTasks.add(deadlineTask3);
		deadlineTasks.add(deadlineTask4);

		eventTasks.add(eventTask1);
		eventTasks.add(eventTask2);
		eventTasks.add(eventTask3);
		eventTasks.add(eventTask4);

		allTasks.add(deadlineTask1);
		allTasks.add(deadlineTask2);
		allTasks.add(deadlineTask3);
		allTasks.add(deadlineTask4);
		allTasks.add(eventTask1);
		allTasks.add(eventTask2);
		allTasks.add(eventTask3);
		allTasks.add(eventTask4);
		allTasks.add(floatingTask1);
		allTasks.add(floatingTask2);
		allTasks.add(floatingTask3);
		
		overdueTasks.add(deadlineTask1);
		overdueTasks.add(deadlineTask2);
		doneTasks.add(deadlineTask1);
		doneTasks.add(deadlineTask2);
	}

	@Test
	public void testStringForParsingForEdit() throws ClassNotFoundException, IOException {

		String input = "edit 1 buy bed by 291215";
		String[] commandParts = input.split(" ");
		String[] expectedParts = { "add", "buy", "bed", "by", "291215" };

		assertArrayEquals("edits the input to help add a new task to merge with the old one", expectedParts,
				tester.getStringForParsing(commandParts));
	}

	@Test
	public void testAddTaskToList() throws ClassNotFoundException, IOException {

		Task newTask = new Task();

		newTask.setTaskType("floating");
		tester.addTaskToList(newTask);

		newTask.setTaskStartTime("1040");
		newTask.setTaskEndTime("1150");

		newTask.setTaskType("deadline");
		tester.addTaskToList(newTask);

		// Also testing fillUpTime(Task), roundDownTime(String),
		// roundUpTime(String);

		newTask.setTaskStartTime("0050");
		newTask.setTaskEndTime("0059");

		newTask.setTaskType("event");
		tester.addTaskToList(newTask);

		newTask.setTaskStartTime("0000");
		newTask.setTaskEndTime("0020");

		newTask.setTaskType("event");
		tester.addTaskToList(newTask);

		newTask.setTaskStartTime("1230");
		newTask.setTaskEndTime("1400");

		newTask.setTaskType("event");
		tester.addTaskToList(newTask);

	}

	@Test
	public void testDeleteTaskFromList() throws Exception {
		
		int deleteID = 1;
		
		Task taskToDelete = new Task();
		taskToDelete.setTaskType("floating");
		listType = TASKTYPE_floating;
		tester.addTaskToList(taskToDelete);
		
		assertEquals("deleting first floating task", taskToDelete ,tester.deleteTaskFromList(deleteID));

	}
	
	@Test
	public void testDeleteTaskFromList2() throws Exception {
		
		int deleteID = 1;
		
		Task taskToDelete = new Task();
		taskToDelete.setTaskType("event");
		listType = TASKTYPE_event;
		tester.addTaskToList(taskToDelete);
		
		assertEquals("deleting first deadline task", taskToDelete ,tester.deleteTaskFromList(deleteID));

	}

	@Test
	public void testRemoveTaskFromFloatingList() throws Exception {
		int deleteID = 1;
		Task floatingTask = new Task();
		floatingTask.setTaskType("floating");
		tester.addTaskToList(floatingTask);
		
		assertEquals("deleting first floating task", floatingTask, tester.removeTaskFromFloatingList(deleteID));
	}
	
	@Test
	public void testRemoveTaskFromDeadlineList() throws Exception {
		int deleteID = 1;
		Task deadlineTask = new Task();
		deadlineTask.setTaskType("deadline");
		tester.addTaskToList(deadlineTask);
		
		assertEquals("deleting first deadline task", deadlineTask, tester.removeTaskFromDeadlineList(deleteID));
	}
	
	@Test
	public void testRemoveTaskFromEventList() throws Exception {
		int deleteID = 1;
		Task eventTask = new Task();
		eventTask.setTaskType("event");
		tester.addTaskToList(eventTask);
		
		assertEquals("deleting first event task", eventTask, tester.removeTaskFromEventList(deleteID));
	}
	
	@Test
	public void testRemoveTaskFromOverdueList() throws Exception {
		int deleteID = 1;
		Task overdueTask = new Task();
		overdueTask.setTaskType("overdue");
		overdueTask.setTaskIsOverdue();
		tester.addTaskToList(overdueTask);
		
		assertEquals("deleting first overdue task", overdueTask, tester.removeTaskFromOverdueList(deleteID));
	}
	
	@Test
	public void testRemoveTaskFromDoneList() throws Exception {
		int deleteID = 1;
		Task doneTask = new Task();
		doneTask.setTaskType("done");
		doneTask.setTaskIsDone();
		tester.addTaskToList(doneTask);
		
		assertEquals("deleting first done task", doneTask, tester.removeTaskFromDoneList(deleteID));
	}

	@Test
	public void testSort() {

		ArrayList<Task> expectedDeadlineSort = new ArrayList<Task>();
		expectedDeadlineSort.add(deadlineTask3);
		expectedDeadlineSort.add(deadlineTask2);
		expectedDeadlineSort.add(deadlineTask4);
		expectedDeadlineSort.add(deadlineTask1);

		assertEquals("test correct task is deleted", expectedDeadlineSort, tester.executeSort(deadlineTasks));

		ArrayList<Task> expectedEventSort = new ArrayList<Task>();
		expectedEventSort.add(eventTask3);
		expectedEventSort.add(eventTask4);
		expectedEventSort.add(eventTask1);
		expectedEventSort.add(eventTask2);

		assertEquals("test correct task is deleted", expectedEventSort, tester.executeSort(eventTasks));

		ArrayList<Task> expectedFloatingSort = new ArrayList<Task>();
		expectedFloatingSort.add(floatingTask1);
		expectedFloatingSort.add(floatingTask2);
		expectedFloatingSort.add(floatingTask3);

		assertEquals("test correct task is deleted", expectedFloatingSort, tester.executeSort(floatingTasks));

		ArrayList<Task> expectedSort = new ArrayList<Task>();
		expectedSort.add(eventTask3);
		expectedSort.add(eventTask4);
		expectedSort.add(deadlineTask3);
		expectedSort.add(deadlineTask2);
		expectedSort.add(eventTask1);
		expectedSort.add(eventTask2);
		expectedSort.add(deadlineTask4);
		expectedSort.add(deadlineTask1);
		expectedSort.add(floatingTask1);
		expectedSort.add(floatingTask2);
		expectedSort.add(floatingTask3);

		assertEquals("test correct task is deleted", expectedSort, tester.executeSort(allTasks));
	}
}
```
