# A0124209N
###### .metadata\.plugins\org.eclipse.core.resources\.history\1a\80e91cadf986001517b1b65a1f8245b9
``` 
package LemonBuddy;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandExecutor extends FileStorage {
	private static final String TASKTYPE_EVENT = "event";
	private static final String TASKTYPE_DEADLINE = "deadline";
	private static final String TASKTYPE_overdue = "overdue";
	private static final String TASKTYPE_done = "done";
	private static final String TASKTYPE_FLOATING = "floating";
	private static final java.util.logging.Logger logger = Logger.getLogger("CommandExecutor");

	private static String path;
	private Parser parser;
	String lastState;
	Stack<String> lastStates;
	Stack<String> undoneStates;

	private static String listType;

	private static ArrayList<Task> floatingTasks;
	private static ArrayList<Task> deadlineTasks;
	private static ArrayList<Task> eventTasks;
	private static ArrayList<Task> allTasks;
	private static ArrayList<Task> doneTasks;
	private static ArrayList<Task> overdueTasks;
	private static ArrayList<Task> listToTimeline;
	private static ArrayList<Task> searchResults;
	private static String[] date = { "", "" };
	private static CommandExecutor commandexecutor;
	private static Task selectedTask;

	public CommandExecutor() throws Exception {
		parser = Parser.getInstance();
		listType = "overdue";
		date[1] = parser.getCurrentDate();
		lastStates = new Stack<String>();
		undoneStates = new Stack<String>();
		lastState = "";
		path = "";
		floatingTasks = new ArrayList<Task>();
		deadlineTasks = new ArrayList<Task>();
		eventTasks = new ArrayList<Task>();
		allTasks = new ArrayList<Task>();
		doneTasks = new ArrayList<Task>();
		overdueTasks = new ArrayList<Task>();
		searchResults = new ArrayList<Task>();
	}

	public static CommandExecutor getInstance() throws Exception {
		if (commandexecutor == null) {
			commandexecutor = new CommandExecutor();
		}
		return commandexecutor;
	}

	public void updateLists() throws Exception {
		ArrayList<ArrayList<Task>> updatedLists = FileStorage.readStringAsObject(path);
		removeNewest(updatedLists);
		floatingTasks = updatedLists.get(0);
		deadlineTasks = updatedLists.get(1);
		eventTasks = updatedLists.get(2);
		allTasks = updatedLists.get(3);
		doneTasks = updatedLists.get(4);
		overdueTasks = updatedLists.get(5);
	}

	public void removeNewest(ArrayList<ArrayList<Task>> updatedLists) {
		for (int counter = 0; counter < updatedLists.size(); counter++) {
			for (int counter1 = 0; counter1 < updatedLists.get(counter).size(); counter1++) {
				if (updatedLists.get(counter).get(counter1).getTaskIsNewest()) {
					updatedLists.get(counter).get(counter1).removeTaskIsNewest();
				}
			}
		}
	}

	public void executeAdd(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing Add");
		Task newTask = parser.parseTask(commandParts);
		newTask.setTaskIsNewest();
		addTaskToList(newTask);
		selectedTask = newTask;
		writeToFile();
	}

	public void executeEdit(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing edit");
		int deleteIndex = Integer.valueOf(commandParts[1]);
		String[] stringToParse = getStringForParsing(commandParts);
		Task newTask = parser.parseTask(stringToParse);
		Task oldTask = deleteTaskFromList(deleteIndex);
		newTask.mergeTaskDetails(oldTask);
		addTaskToList(newTask);
		selectedTask = newTask;
		listType = newTask.getTaskType();
		writeToFile();
		updateLists();
	}

	public void executeSearch(String[] commandParts) throws ClassNotFoundException, IOException {
		searchResults.clear();
		listType = "search";
		int phraseSize = commandParts.length - 1;
		String searchKeyword = commandParts[1];
		if (phraseSize > 1) {
			for (int i = 2; i < phraseSize + 1; i++) {
				searchKeyword += " ";
				searchKeyword += commandParts[i];
			}
		}

		searchKeyword.toLowerCase();

		for (int j = 0; j < allTasks.size(); j++) {
			Task searchedTask = allTasks.get(j);
			if (searchedTask.getTaskName().toLowerCase().contains(searchKeyword)
					|| searchedTask.getTaskDescription().toLowerCase().contains(searchKeyword)) {
				searchResults.add(searchedTask);
			}
		}
		;
	}

	public void executeDelete(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing Delete");
		int deleteId = Integer.valueOf(commandParts[1]);
		deleteTaskFromList(deleteId);
		writeToFile();
	}

	public void executeList(String[] commandParts) throws Exception {
		listType = commandParts[1];
	}

	public void executeUndo() throws IOException, Exception {
		if (lastStates.isEmpty()) {
			throw new Exception("Already at last undo");
		}
		undoneStates.push(FileStorage.readStringAsString(path));
		FileStorage.clear();
		FileStorage.writeStringAsString(lastStates.pop());
		updateLists();
	}

	public void executeDone(String[] commandParts) throws Exception, IOException {
		int deleteID = Integer.valueOf(commandParts[1]);
		Task doneTask = deleteTaskFromList(deleteID);
		doneTask.setTaskType("done");
		doneTasks.add(doneTask);
		writeToFile();
	}

	public void executeView(String[] commandParts) throws ClassNotFoundException, IOException, ParseException {
		logger.log(Level.INFO, "Executing View");
		listType = "date";
		date[1] = commandParts[1];
		SimpleDateFormat sdf = new SimpleDateFormat("ddMMyy");
		Date dateToView = sdf.parse(date[1]);
		ArrayList<Task> tasksOnDate = new ArrayList<Task>();
		Task currentTask;
		for (int index = 0; index < eventTasks.size(); index++) {
			currentTask = eventTasks.get(index);
			Date dateStart = sdf.parse(currentTask.getTaskStartDate());
			Date dateEnd = sdf.parse(currentTask.getTaskEndDate());
			if ((dateEnd.compareTo(dateToView) >= 0) && (dateStart.compareTo(dateToView) <= 0)) {
				fillUpTime(currentTask);
				tasksOnDate.add(currentTask);
			}
		}

		ArrayList<Task> temp = new ArrayList<Task>();
		temp.addAll(deadlineTasks);
		temp.addAll(overdueTasks);
		for (int index = 0; index < temp.size(); index++) {
			currentTask = temp.get(index);
			if (currentTask.getTaskEndDate().equals(date[1])) {
				fillUpTime(currentTask);
				tasksOnDate.add(currentTask);
			}
		}
		listToTimeline = Sort.sortByTime(tasksOnDate);
	}

```
###### .metadata\.plugins\org.eclipse.core.resources\.history\1a\d0c311a3f886001517b1b65a1f8245b9
``` 
package LemonBuddy;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandExecutor extends FileStorage {
	private static final String TASKTYPE_EVENT = "event";
	private static final String TASKTYPE_DEADLINE = "deadline";
	private static final String TASKTYPE_overdue = "overdue";
	private static final String TASKTYPE_done = "done";
	private static final String TASKTYPE_FLOATING = "floating";
	private static final java.util.logging.Logger logger = Logger.getLogger("CommandExecutor");

	private static String path;
	private Parser parser;
	String lastState;
	Stack<String> lastStates;
	Stack<String> undoneStates;

	private static String listType;

	private static ArrayList<Task> floatingTasks;
	private static ArrayList<Task> deadlineTasks;
	private static ArrayList<Task> eventTasks;
	private static ArrayList<Task> allTasks;
	private static ArrayList<Task> doneTasks;
	private static ArrayList<Task> overdueTasks;
	private static ArrayList<Task> listToTimeline;
	private static ArrayList<Task> searchResults;
	private static String[] date = { "", "" };
	private static CommandExecutor commandexecutor;
	private static Task selectedTask;

	public CommandExecutor() throws Exception {
		parser = Parser.getInstance();
		listType = "overdue";
		date[1] = parser.getCurrentDate();
		lastStates = new Stack<String>();
		undoneStates = new Stack<String>();
		lastState = "";
		path = "";
		floatingTasks = new ArrayList<Task>();
		deadlineTasks = new ArrayList<Task>();
		eventTasks = new ArrayList<Task>();
		allTasks = new ArrayList<Task>();
		doneTasks = new ArrayList<Task>();
		overdueTasks = new ArrayList<Task>();
		searchResults = new ArrayList<Task>();
	}

	public static CommandExecutor getInstance() throws Exception {
		if (commandexecutor == null) {
			commandexecutor = new CommandExecutor();
		}
		return commandexecutor;
	}

	public void updateLists() throws Exception {
		ArrayList<ArrayList<Task>> updatedLists = FileStorage.readStringAsObject(path);
		removeNewest(updatedLists);
		floatingTasks = updatedLists.get(0);
		deadlineTasks = updatedLists.get(1);
		eventTasks = updatedLists.get(2);
		allTasks = updatedLists.get(3);
		doneTasks = updatedLists.get(4);
		overdueTasks = updatedLists.get(5);
	}

	public void removeNewest(ArrayList<ArrayList<Task>> updatedLists) {
		for (int counter = 0; counter < updatedLists.size(); counter++) {
			for (int counter1 = 0; counter1 < updatedLists.get(counter).size(); counter1++) {
				if (updatedLists.get(counter).get(counter1).getTaskIsNewest()) {
					updatedLists.get(counter).get(counter1).removeTaskIsNewest();
				}
			}
		}
	}

	public void executeAdd(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing Add");
		Task newTask = parser.parseTask(commandParts);
		newTask.setTaskIsNewest();
		addTaskToList(newTask);
		selectedTask = newTask;
		writeToFile();
	}

	public void executeEdit(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing edit");
		int deleteIndex = Integer.valueOf(commandParts[1]);
		String[] stringToParse = getStringForParsing(commandParts);
		Task newTask = parser.parseTask(stringToParse);
		Task oldTask = deleteTaskFromList(deleteIndex);
		newTask.mergeTaskDetails(oldTask);
		addTaskToList(newTask);
		selectedTask = newTask;
		listType = newTask.getTaskType();
		writeToFile();
		updateLists();
	}

	public void executeSearch(String[] commandParts) throws ClassNotFoundException, IOException {
		searchResults.clear();
		listType = "search";
		int phraseSize = commandParts.length - 1;
		String searchKeyword = commandParts[1];
		if (phraseSize > 1) {
			for (int i = 2; i < phraseSize + 1; i++) {
				searchKeyword += " ";
				searchKeyword += commandParts[i];
			}
		}

		searchKeyword.toLowerCase();

		for (int j = 0; j < allTasks.size(); j++) {
			Task searchedTask = allTasks.get(j);
			if (searchedTask.getTaskName().toLowerCase().contains(searchKeyword)
					|| searchedTask.getTaskDescription().toLowerCase().contains(searchKeyword)) {
				searchResults.add(searchedTask);
			}
		}
		;
	}

	public void executeDelete(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing Delete");
		int deleteId = Integer.valueOf(commandParts[1]);
		deleteTaskFromList(deleteId);
		writeToFile();
	}

	public void executeList(String[] commandParts) throws Exception {
		listType = commandParts[1];
	}

	public void executeUndo() throws IOException, Exception {
		if (lastStates.isEmpty()) {
			throw new Exception("Already at last undo");
		}
		undoneStates.push(FileStorage.readStringAsString(path));
		FileStorage.clear();
		FileStorage.writeStringAsString(lastStates.pop());
		updateLists();
	}

	public void executeDone(String[] commandParts) throws Exception, IOException {
		int deleteID = Integer.valueOf(commandParts[1]);
		Task doneTask = deleteTaskFromList(deleteID);
		doneTask.setTaskType("done");
		doneTasks.add(doneTask);
		writeToFile();
	}

	public void executeView(String[] commandParts) throws ClassNotFoundException, IOException, ParseException {
		logger.log(Level.INFO, "Executing View");
		listType = "date";
		date[1] = commandParts[1];
		SimpleDateFormat sdf = new SimpleDateFormat("ddMMyy");
		Date dateToView = sdf.parse(date[1]);
		ArrayList<Task> tasksOnDate = new ArrayList<Task>();
		Task currentTask;
		for (int index = 0; index < eventTasks.size(); index++) {
			currentTask = eventTasks.get(index);
			Date dateStart = sdf.parse(currentTask.getTaskStartDate());
			Date dateEnd = sdf.parse(currentTask.getTaskEndDate());
			if ((dateEnd.compareTo(dateToView) >= 0) && (dateStart.compareTo(dateToView) <= 0)) {
				fillUpTime(currentTask);
				tasksOnDate.add(currentTask);
			}
		}

		ArrayList<Task> temp = new ArrayList<Task>();
		temp.addAll(deadlineTasks);
		temp.addAll(overdueTasks);
		for (int index = 0; index < temp.size(); index++) {
			currentTask = temp.get(index);
			if (currentTask.getTaskEndDate().equals(date[1])) {
				fillUpTime(currentTask);
				tasksOnDate.add(currentTask);
			}
		}
		listToTimeline = Sort.sortByTime(tasksOnDate);
	}

```
###### .metadata\.plugins\org.eclipse.core.resources\.history\64\90b97696f986001517b1b65a1f8245b9
``` 
package LemonBuddy;

import java.io.Serializable;
import java.util.ArrayList;

import javafx.beans.property.SimpleStringProperty;

public class Task implements Serializable {
	private String taskName;
	private String taskType;
	private String taskStartDate;
	private String taskEndDate;
	private String taskPriority;
	private String taskDescription;
	private boolean taskIsDone;
	private boolean taskIsOverdue;
	private boolean taskIsNewest;
	private String taskStartTime;
	private String taskEndTime;

	private SimpleStringProperty displayId;
	private SimpleStringProperty displayName;
	private SimpleStringProperty displayStartDate;
	private SimpleStringProperty displayEndDate;
	private SimpleStringProperty displayStartTime;
	private SimpleStringProperty displayEndTime;
	private SimpleStringProperty displayPriority;
	private SimpleStringProperty displayDescription;
	private SimpleStringProperty[] displayTimmings = new SimpleStringProperty[48];
	
	public String toString() {
		String temp = "";
		temp = temp + "taskname:" + taskName + ";";
		temp = temp + "tasktype:" + taskType + ";";
		temp = temp + "taskIsDone:" + taskIsDone + ";";
		temp = temp + "taskIsOverdue:" + taskIsOverdue + ";";
		temp = temp + "taskIsNewest:" + taskIsNewest + ";";
		temp = temp + "taskStartDate:" + taskStartDate + ";";
		temp = temp + "taskEndDate:" + taskEndDate + ";";
		temp = temp + "taskPriority:" + taskPriority + ";";
		temp = temp + "taskDescription:" + taskDescription + ";";
		temp = temp + "taskStartTime:" + taskStartTime + ";";
		temp = temp + "taskEndTime:" + taskEndTime + ";";
		temp = temp + "\n";
		return temp;
	}

	//initializer
	public Task(){
		taskName = "";
		taskType = "floating";
		taskStartDate = "-1";
		taskEndDate = "-1";
		taskPriority = "low";
		taskDescription = "";
		taskIsDone = false;
		taskIsOverdue = false;
		taskIsNewest = false;
		taskStartTime = "-1";
		taskEndTime = "-1";
	}
	
	//TASK DATA MODIFIERS//
	
	public Task mergeTaskDetails(Task initialTask) {
		if (this.taskName.equals("")) {
			this.taskName = initialTask.getTaskName();
		}
		if (this.taskType.equals("floating")) {
			this.taskType = initialTask.getTaskType();
			this.taskStartDate = initialTask.getTaskStartDate();
			this.taskEndDate = initialTask.getTaskEndDate();
			this.taskStartTime = initialTask.getTaskStartTime();
			this.taskEndTime = initialTask.getTaskEndTime();
		}
		if (this.taskPriority.equals("low")) {
			this.taskPriority = initialTask.getTaskPriority();
		}
		if (this.taskDescription.equals("")) {
			this.taskDescription = initialTask.getTaskDescription();
		}
		return this;
	}

	public void setTaskName(String taskName) {
		this.taskName = taskName;
		this.displayName = new SimpleStringProperty(taskName);
	}

	public void setTaskType(String taskType) {
		this.taskType = taskType;
	}

	public void setTaskIsDone() {
		this.taskIsDone = true;
	}

	public void setTaskIsOverdue() {
		this.taskIsOverdue = true;
	}

	public void setTaskIsNewest() {
		this.taskIsNewest = true;
	}

	public void removeTaskIsNewest() {
		this.taskIsNewest = false;
	}

	public void setTaskStartDate(String taskStartDate) {
		this.taskStartDate = taskStartDate.replaceAll("[^\\d-]", "");
		this.displayStartDate = new SimpleStringProperty(this.taskStartDate);
	}

	public void setTaskEndDate(String taskEndDate) {
		this.taskEndDate = taskEndDate.replaceAll("[^\\d-]", "");
		this.displayEndDate = new SimpleStringProperty(this.taskEndDate);
	}

	public void setTaskStartTime(String taskStartTime) {
		this.taskStartTime = taskStartTime.replaceAll("[^\\d-]", "");
		this.displayStartTime = new SimpleStringProperty(this.taskStartTime);
	}

	public void setTaskEndTime(String taskEndTime) {
		this.taskEndTime = taskEndTime.replaceAll("[^\\d-]", "");
		this.displayEndTime = new SimpleStringProperty(this.taskEndTime);
	}

	public void setTaskPriority(String taskPriority) throws Exception {
		if(!(taskPriority.equals("low")||taskPriority.equals("medium")||taskPriority.equals("high"))){
			throw new Exception("Invalid priority type");
		}
		this.taskPriority = taskPriority;
		this.displayPriority = new SimpleStringProperty(this.taskPriority);
	}

	public void setTaskDescription(String taskDescription) {
		this.taskDescription = taskDescription;
		this.displayDescription = new SimpleStringProperty(this.taskDescription);
	}
	
	public void setDisplayId(String index) {
		this.displayId = new SimpleStringProperty(index);
	}
	
	public void setEventTime(int time) {
		SimpleStringProperty temp = new SimpleStringProperty("1");
		this.displayTimmings[time] = temp;
	}
	
	public void setDeadlineTime(int time) {
		SimpleStringProperty temp = new SimpleStringProperty("-1");
		this.displayTimmings[time] = temp;
	}

	//RETRIEVERS//
	
	public String getTaskName() {
		StringBuffer buffer = new StringBuffer(this.taskName);
		return buffer.toString();
	}

	public String getTaskType() {
		StringBuffer buffer = new StringBuffer(this.taskType);
		return buffer.toString();
	}

	public Boolean getTaskIsDone() {
		return this.taskIsDone;

	}

	public Boolean getTaskIsOverdue() {
		return this.taskIsOverdue;
	}

	public Boolean getTaskIsNewest() {
		return this.taskIsNewest;
	}

	public String getTaskStartDate() {
		return this.taskStartDate;
	}

	public Boolean taskStartDateIsEmpty() {
		if (this.taskStartDate == "-1") {
			return true;
		} else {
			return false;
		}
	}

	public String getTaskEndDate() {
		return this.taskEndDate;
	}

	public Boolean taskEndDateIsEmpty() {
		if (this.taskEndDate == "-1") {
			return true;
		} else {
			return false;
		}
	}

	public String getTaskStartTime() {
		return this.taskStartTime;
	}
	
	public Boolean taskStartTimeIsEmpty(){
		if (this.taskStartTime == "-1") {
			return true;
		} else {
			return false;
		}
	}
	
	public String getTaskEndTime() {
		return this.taskEndTime;
	}

	public Boolean taskEndTimeIsEmpty(){
		if (this.taskEndTime == "-1") {
			return true;
		} else {
			return false;
		}
	}
	
	public String getTaskPriority() {
		StringBuffer buffer = new StringBuffer(this.taskPriority);
		return buffer.toString();
	}

	public String getTaskDescription() {
		StringBuffer buffer = new StringBuffer(this.taskDescription);
		return buffer.toString();
	}

	public SimpleStringProperty getDisplayName() {
		return this.displayName;
	}
	
	public SimpleStringProperty getDisplayStartDate() {
		return this.displayStartDate;
	}
	
	public SimpleStringProperty getDisplayEndDate() {
		return this.displayEndDate;
	}
	
	public SimpleStringProperty getDisplayStartTime() {
		return this.displayStartTime;
	}
	
	public SimpleStringProperty getDisplayEndTime() {
		return this.displayEndTime;
	}
	
	public SimpleStringProperty getDisplayPriority() {
		return this.displayPriority;
	}
	
	public SimpleStringProperty getDisplayDescription() {
		return this.displayDescription;
	}

	public SimpleStringProperty getDisplayId() {
		return this.displayId;
	}
	
	public SimpleStringProperty getTimmings(int num) {
		return this.displayTimmings[num];
	}

}
```
###### .metadata\.plugins\org.eclipse.core.resources\.history\6f\90d1f76bf986001517b1b65a1f8245b9
``` 
package LemonBuddy;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandExecutor extends FileStorage {
	private static final String TASKTYPE_EVENT = "event";
	private static final String TASKTYPE_DEADLINE = "deadline";
	private static final String TASKTYPE_overdue = "overdue";
	private static final String TASKTYPE_done = "done";
	private static final String TASKTYPE_FLOATING = "floating";
	private static final java.util.logging.Logger logger = Logger.getLogger("CommandExecutor");

	private static String path;
	private Parser parser;
	String lastState;
	Stack<String> lastStates;
	Stack<String> undoneStates;

	private static String listType;

	private static ArrayList<Task> floatingTasks;
	private static ArrayList<Task> deadlineTasks;
	private static ArrayList<Task> eventTasks;
	private static ArrayList<Task> allTasks;
	private static ArrayList<Task> doneTasks;
	private static ArrayList<Task> overdueTasks;
	private static ArrayList<Task> listToTimeline;
	private static ArrayList<Task> searchResults;
	private static String[] date = { "", "" };
	private static CommandExecutor commandexecutor;
	private static Task selectedTask;

	public CommandExecutor() throws Exception {
		parser = Parser.getInstance();
		listType = "overdue";
		date[1] = parser.getCurrentDate();
		lastStates = new Stack<String>();
		undoneStates = new Stack<String>();
		lastState = "";
		path = "";
		floatingTasks = new ArrayList<Task>();
		deadlineTasks = new ArrayList<Task>();
		eventTasks = new ArrayList<Task>();
		allTasks = new ArrayList<Task>();
		doneTasks = new ArrayList<Task>();
		overdueTasks = new ArrayList<Task>();
		searchResults = new ArrayList<Task>();
	}

	public static CommandExecutor getInstance() throws Exception {
		if (commandexecutor == null) {
			commandexecutor = new CommandExecutor();
		}
		return commandexecutor;
	}

	public void updateLists() throws Exception {
		ArrayList<ArrayList<Task>> updatedLists = FileStorage.readStringAsObject(path);
		removeNewest(updatedLists);
		floatingTasks = updatedLists.get(0);
		deadlineTasks = updatedLists.get(1);
		eventTasks = updatedLists.get(2);
		allTasks = updatedLists.get(3);
		doneTasks = updatedLists.get(4);
		overdueTasks = updatedLists.get(5);
	}

	public void removeNewest(ArrayList<ArrayList<Task>> updatedLists) {
		for (int counter = 0; counter < updatedLists.size(); counter++) {
			for (int counter1 = 0; counter1 < updatedLists.get(counter).size(); counter1++) {
				if (updatedLists.get(counter).get(counter1).getTaskIsNewest()) {
					updatedLists.get(counter).get(counter1).removeTaskIsNewest();
				}
			}
		}
	}

	public void executeAdd(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing Add");
		Task newTask = parser.parseTask(commandParts);
		newTask.setTaskIsNewest();
		addTaskToList(newTask);
		selectedTask = newTask;
		writeToFile();
	}

	public void executeEdit(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing edit");
		int deleteIndex = Integer.valueOf(commandParts[1]);
		String[] stringToParse = getStringForParsing(commandParts);
		Task newTask = parser.parseTask(stringToParse);
		Task oldTask = deleteTaskFromList(deleteIndex);
		newTask.mergeTaskDetails(oldTask);
		addTaskToList(newTask);
		selectedTask = newTask;
		listType = newTask.getTaskType();
		writeToFile();
		updateLists();
	}

	public void executeSearch(String[] commandParts) throws ClassNotFoundException, IOException {
		searchResults.clear();
		listType = "search";
		int phraseSize = commandParts.length - 1;
		String searchKeyword = commandParts[1];
		if (phraseSize > 1) {
			for (int i = 2; i < phraseSize + 1; i++) {
				searchKeyword += " ";
				searchKeyword += commandParts[i];
			}
		}

		searchKeyword.toLowerCase();

		for (int j = 0; j < allTasks.size(); j++) {
			Task searchedTask = allTasks.get(j);
			if (searchedTask.getTaskName().toLowerCase().contains(searchKeyword)
					|| searchedTask.getTaskDescription().toLowerCase().contains(searchKeyword)) {
				searchResults.add(searchedTask);
			}
		}
		;
	}

	public void executeDelete(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing Delete");
		int deleteId = Integer.valueOf(commandParts[1]);
		deleteTaskFromList(deleteId);
		writeToFile();
	}

	public void executeList(String[] commandParts) throws Exception {
		listType = commandParts[1];
	}

	public void executeUndo() throws IOException, Exception {
		if (lastStates.isEmpty()) {
			throw new Exception("Already at last undo");
		}
		undoneStates.push(FileStorage.readStringAsString(path));
		FileStorage.clear();
		FileStorage.writeStringAsString(lastStates.pop());
		updateLists();
	}

	public void executeDone(String[] commandParts) throws Exception, IOException {
		int deleteID = Integer.valueOf(commandParts[1]);
		Task doneTask = deleteTaskFromList(deleteID);
		doneTask.setTaskType("done");
		doneTasks.add(doneTask);
		writeToFile();
	}

	public void executeView(String[] commandParts) throws ClassNotFoundException, IOException, ParseException {
		logger.log(Level.INFO, "Executing View");
		listType = "date";
		date[1] = commandParts[1];
		SimpleDateFormat sdf = new SimpleDateFormat("ddMMyy");
		Date dateToView = sdf.parse(date[1]);
		ArrayList<Task> tasksOnDate = new ArrayList<Task>();
		Task currentTask;
		for (int index = 0; index < eventTasks.size(); index++) {
			currentTask = eventTasks.get(index);
			Date dateStart = sdf.parse(currentTask.getTaskStartDate());
			Date dateEnd = sdf.parse(currentTask.getTaskEndDate());
			if ((dateEnd.compareTo(dateToView) >= 0) && (dateStart.compareTo(dateToView) <= 0)) {
				fillUpTime(currentTask);
				tasksOnDate.add(currentTask);
			}
		}

		ArrayList<Task> temp = new ArrayList<Task>();
		temp.addAll(deadlineTasks);
		temp.addAll(overdueTasks);
		for (int index = 0; index < temp.size(); index++) {
			currentTask = temp.get(index);
			if (currentTask.getTaskEndDate().equals(date[1])) {
				fillUpTime(currentTask);
				tasksOnDate.add(currentTask);
			}
		}
		listToTimeline = Sort.sortByTime(tasksOnDate);
	}

```
###### .metadata\.plugins\org.eclipse.core.resources\.history\bf\b07998b7f986001517b1b65a1f8245b9
``` 
package LemonBuddy;

import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
public class CommandController {
	private static final String TASKTYPE_OVERDUE = "overdue";

	private static final String TASKTYPE_DONE = "done";

	private static final String TASKTYPE_EVENT = "Event";

	private static final String TASKTYPE_DEADLINE = "Deadline";

	private static final String TASKTYPE_FLOATING = "Floating";

	private static Logger logger = Logger.getLogger("CommandController");

	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_DELETE = "delete";
	private static final String COMMAND_EDIT = "edit";
	private static final String COMMAND_VIEW = "view";
	private static final String COMMAND_LIST = "list";
	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_REDO = "redo";
	private static final String COMMAND_DONE = TASKTYPE_DONE;
	private static final String COMMAND_SEARCH = "search";
	private static CommandExecutor commandexecutor;
	private static CommandController commandcontroller;

	private static boolean isSuccesful;
	private static String commandType;
	private static String errorMessage;

	public CommandController() throws Exception {
		commandexecutor = CommandExecutor.getInstance();
		commandexecutor.saveLastState();
		commandexecutor.updateLists();
	}

	public static CommandController getInstance() throws IOException, Exception {
		if (commandcontroller == null) {
			commandcontroller = new CommandController();
		}
		return commandcontroller;

	}

	public void processCommand(String command) {
		logger.log(Level.INFO, "going to start processing");
		try {
			String[] commandParts = commandcontroller.splitCommand(command);
			commandType = commandParts[0];

			executeSaveLastState(commandType);

			switch (commandType) {
			case COMMAND_ADD:
				commandexecutor.executeAdd(commandParts);
				isSuccesful = true;
				break;

			case COMMAND_DELETE:
				if (commandParts[1].matches("[0-9]+") == false) {
					throw new Exception("Index is not in numerical form");
				}
				commandexecutor.executeDelete(commandParts);
				isSuccesful = true;
				break;

			case COMMAND_EDIT:
				if (commandParts[1].matches("[0-9]+") == false) {
					throw new Exception("Index is not in numerical form");
				}
				commandexecutor.executeEdit(commandParts);
				isSuccesful = true;
				break;

			case COMMAND_UNDO:
				commandexecutor.executeUndo();
				isSuccesful = true;
				break;

			case COMMAND_REDO:
				commandexecutor.executeRedo();
				isSuccesful = true;
				break;

			case COMMAND_VIEW:
				DateFormat df = new SimpleDateFormat("ddMMyy");
				df.setLenient(false);
				df.parse(commandParts[1]);
				commandexecutor.executeView(commandParts);
				isSuccesful = true;
				break;

			case COMMAND_LIST:
				if (!(commandParts[1].equals(TASKTYPE_FLOATING) || commandParts[1].equals(TASKTYPE_DEADLINE)
						|| commandParts[1].equals(TASKTYPE_EVENT) || commandParts[1].equals(TASKTYPE_DONE)
						|| commandParts[1].equals(TASKTYPE_OVERDUE))) {
					throw new Exception("Invalid task type");
				}
				commandexecutor.executeList(commandParts);
				isSuccesful = true;
				break;

			case COMMAND_DONE:
				if ((commandParts[1].matches("[0-9]+") == false)) {
					throw new Exception("Index is not in numerical form");
				}
				commandexecutor.executeDone(commandParts);
				isSuccesful = true;
				break;

			case COMMAND_SEARCH:
				commandexecutor.executeSearch(commandParts);
				isSuccesful = true;
				break;
			case "exit":
				System.exit(0);
			default:
				throw new Exception("Invalid Command");
			}

		} catch (Exception e) {
			logger.log(Level.WARNING, "processing error", e);
			errorMessage = (e.toString());
			isSuccesful = false;
		}

	}
//@author A0127147H
	private static void executeSaveLastState(String commandType) throws Exception, IOException {
		if (commandType.equals(COMMAND_ADD) || commandType.equals(COMMAND_DELETE) || commandType.equals(COMMAND_EDIT)
				|| commandType.equals(COMMAND_DONE)) {
			commandexecutor.saveLastState();
		}
	}

	public String[] splitCommand(String command) {
		String[] commandParts = command.split(" ");
		return commandParts;
	}

	private boolean isValidTaskType(String taskType) {
		if (taskType.equals(TASKTYPE_FLOATING) || taskType.equals(TASKTYPE_DEADLINE)
				|| taskType.equals(TASKTYPE_EVENT)) {
			return true;
		} else
			return false;
	}

	public ArrayList<ArrayList<Task>> passListsToGUI() throws Exception {
		return commandexecutor.passListsToGUI();
	}

	public String getDate() {
		return commandexecutor.passDate();
	}

	public String getListType() {
		return commandexecutor.passListType();
	}

	public String getNotificationMessage() {
		String temp = errorMessage;
		errorMessage = "";
		return temp;
	}

	public boolean checkForSuccessfulCommand() {
		return isSuccesful;
	}

	public String passCommand() {
		return commandType;
	}

	public Task getSelectedTask() {
		return commandexecutor.passSelectedTask();
	}
}
```
###### .metadata\.plugins\org.eclipse.core.resources\.history\c6\7037af8df886001517b1b65a1f8245b9
``` 
package LemonBuddy;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Parser {

	private static final String DATETIMEFORMAT = "ddMMyy";
	private static final String KEYWORD_TO = "to";
	private static final String SIMPLEDATETIMEFORMAT = "ddMMyy HHmm";
	private static final String KEYWORD_TOMORROW = "tomorrow";
	private static final String KEYWORD_BY = "by";
	private static final String KEYWORD_DESCRIPTION = "desc";
	private static final String KEYWORD_PRIORITY = "*";
	private static final String KEYWORD_FROM = "from";
	
	private static final String KEYWORD_ON = "on";
	private static final String TASKTYPE_DEADLINE = "deadline";
	private static final String TASKTYPE_EVENT = "event";
	private static Parser parser;
	private static Logger logger = Logger.getLogger("Parser");
	
	public static Parser getInstance(){
		if(parser == null)
			parser = new Parser();
		return parser;
	}
	/***************************************Create Task from string ******************************************************************/
	public Task parseTask(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing parse task");
		Task newTask = new Task();
		int wordIndex = 1;
		String taskName = "";
		parseTaskName(commandParts, newTask, wordIndex, taskName);
		parseDescription(commandParts, newTask, wordIndex);
		parsePriority(commandParts, newTask, wordIndex);
		parseTime(commandParts, newTask, wordIndex);

		return newTask;
	}

	/************************************** Builds name until first keyword ******************************************************************/
	private int parseTaskName(String[] commandParts, Task newTask, int wordIndex, String taskName) {
		logger.log(Level.INFO, "Parsing Name");
		while (true) {

			if (commandParts[wordIndex].equals(KEYWORD_ON) || commandParts[wordIndex].equals(KEYWORD_FROM)
					|| commandParts[wordIndex].substring(0, 1).equals(KEYWORD_PRIORITY)
					|| commandParts[wordIndex].equals(KEYWORD_DESCRIPTION)
					|| commandParts[wordIndex].equals(KEYWORD_BY)) {
				break;
			}
			taskName = taskName + commandParts[wordIndex++];
			if (wordIndex >= commandParts.length) {
				break;
			}
			taskName = taskName + " ";
		}
		taskName = taskName.trim();
		newTask.setTaskName(taskName);
		return wordIndex;
	}

	/**************************************** Builds description after KEYWORD_DESCRIPTION *****************************************/
	private int parseDescription(String[] commandParts, Task newTask, int wordIndex) {
		logger.log(Level.INFO, "Parsing description");
		int initialIndex = wordIndex;
		while (wordIndex < commandParts.length) {
			if (commandParts[wordIndex].equals(KEYWORD_DESCRIPTION)) {
				String taskDesc = "";
				wordIndex++;
				while (true) {
					taskDesc = taskDesc + commandParts[wordIndex++];
					if (wordIndex == commandParts.length) {
						break;
					}
					taskDesc = taskDesc + " ";
				}
				newTask.setTaskDescription(taskDesc);
			}
			wordIndex++;
		}
		return initialIndex;
	}

	/********************************* Builds priority after detecting KEYWORD_PRIORITY *******************/
	private int parsePriority(String[] commandParts, Task newTask, int wordIndex) throws Exception {
		logger.log(Level.INFO, "Parsing priority");
		int initialIndex = wordIndex;
		while (wordIndex < commandParts.length) {
			if (commandParts[wordIndex].substring(0, 1).equals(KEYWORD_PRIORITY)) {
				newTask.setTaskPriority(commandParts[wordIndex].substring(1));
			}
			wordIndex++;
		}
		return initialIndex;
	}

	private int parseTime(String[] commandParts, Task newTask, int wordIndex) throws Exception {

		detectFromToFormat(commandParts);
		setInputTime(commandParts, newTask, wordIndex);
		setFromToDefaultTime(newTask);
		setDeadlineDefaultTime(newTask);

		checkValidDateTimeInput(newTask);
		return wordIndex;
	}

	private void checkValidDateTimeInput(Task newTask) throws ParseException, Exception {
		if (newTask.getTaskType().equals(TASKTYPE_EVENT)) {

			SimpleDateFormat sdf = new SimpleDateFormat(DATETIMEFORMAT);
			Date date1 = sdf.parse(newTask.getTaskStartDate());
			Date date2 = sdf.parse(newTask.getTaskEndDate());
			if (date1.after(date2)) {
				throw new Exception("Start date is after end date");
			}
			if (newTask.getTaskStartDate().equals(newTask.getTaskEndDate())) {
				if (Integer.parseInt(newTask.getTaskStartTime()) > Integer.parseInt(newTask.getTaskEndTime())) {
					throw new Exception("Start time is after end time");
				}
			}
		}
	}

	private void setInputTime(String[] commandParts, Task newTask, int wordIndex) throws Exception {
		String[] timeInfo = new String[2];
		while (wordIndex < commandParts.length) {
			if (commandParts[wordIndex].equals(KEYWORD_DESCRIPTION)) {
				break;
			}
			switch (commandParts[wordIndex++]) {

			case KEYWORD_ON:
				timeInfo = getTimeInfo(commandParts, newTask, wordIndex);
				newTask.setTaskStartDate(timeInfo[0]);
				newTask.setTaskStartTime(timeInfo[1]);
				setOnDefaultTime(newTask);
				timeInfo = addOneHour(newTask.getTaskStartDate(), newTask.getTaskStartTime());
				newTask.setTaskEndDate(timeInfo[0]);
				newTask.setTaskEndTime(timeInfo[1]);

				newTask.setTaskType(TASKTYPE_EVENT);
				break;
			case KEYWORD_BY:
				timeInfo = getTimeInfo(commandParts, newTask, wordIndex);
				newTask.setTaskEndDate(timeInfo[0]);
				newTask.setTaskEndTime(timeInfo[1]);
				newTask.setTaskType(TASKTYPE_DEADLINE);
				break;
			case KEYWORD_FROM:
				timeInfo = getTimeInfo(commandParts, newTask, wordIndex);
				newTask.setTaskStartDate(timeInfo[0]);
				newTask.setTaskStartTime(timeInfo[1]);
				for (int i = wordIndex; i < commandParts.length; i++) {
					if (commandParts[i].equals(KEYWORD_TO)) {
						i++;
						wordIndex = i;
						break;
					}
				}
				timeInfo = getTimeInfo(commandParts, newTask, wordIndex);

				newTask.setTaskEndDate(timeInfo[0]);
				newTask.setTaskEndTime(timeInfo[1]);
				newTask.setTaskType(TASKTYPE_EVENT);
				break;
			}

		}
	}

	private void setOnDefaultTime(Task newTask) {
		if (newTask.taskStartDateIsEmpty() && newTask.taskEndDateIsEmpty()) {
			newTask.setTaskStartDate(getCurrentDate());
			newTask.setTaskEndDate(getCurrentDate());
		}
		if (newTask.taskStartDateIsEmpty() && !newTask.taskEndDateIsEmpty()) {
			newTask.setTaskStartDate(newTask.getTaskEndDate());
		}
		if (!newTask.taskStartDateIsEmpty() && newTask.taskEndDateIsEmpty()) {
			newTask.setTaskEndDate(newTask.getTaskStartDate());
		}
		if (newTask.taskStartTimeIsEmpty() && newTask.taskEndTimeIsEmpty()) {
			newTask.setTaskStartTime(getCurrentTime());
			newTask.setTaskEndTime(getCurrentTime());
		}
	}

	//@author A0127147H
	private void detectFromToFormat(String[] commandParts) throws Exception {
		Boolean from = false;
		Boolean to = false;
		for (String part : commandParts) {
			if (part.contains(KEYWORD_FROM)) {
				from = true;
			}
		}
		for (String part : commandParts) {
			if (part.contains(KEYWORD_TO)) {
				to = true;
			}
		}
		if (from) {
			if (!to) {
				throw new Exception("Missing \"to\" from command");
			}
		}
	}

	private void setDeadlineDefaultTime(Task newTask) {
		if (newTask.getTaskType().equals(TASKTYPE_DEADLINE)) {
			if (newTask.taskStartDateIsEmpty() && newTask.taskEndDateIsEmpty()) {
				newTask.setTaskEndDate(getCurrentDate());
			}
			if (newTask.taskStartTimeIsEmpty() && newTask.taskEndTimeIsEmpty()) {
				newTask.setTaskEndTime(getCurrentTime());
			}
		}
	}

	private void setFromToDefaultTime(Task newTask) {
		if (newTask.getTaskType().equals(TASKTYPE_EVENT)) {
			if (newTask.taskStartDateIsEmpty() && newTask.taskEndDateIsEmpty()) {
				newTask.setTaskStartDate(getCurrentDate());
				newTask.setTaskEndDate(getCurrentDate());
			}
			if (newTask.taskStartDateIsEmpty() && !newTask.taskEndDateIsEmpty()) {
				newTask.setTaskStartDate(newTask.getTaskEndDate());
			}
			if (!newTask.taskStartDateIsEmpty() && newTask.taskEndDateIsEmpty()) {
				newTask.setTaskEndDate(newTask.getTaskStartDate());
			}
			if (newTask.taskStartTimeIsEmpty() && newTask.taskEndTimeIsEmpty()) {
				newTask.setTaskStartTime("0000");
				newTask.setTaskEndTime("2359");
			}
			if (newTask.taskStartTimeIsEmpty() && !newTask.taskEndTimeIsEmpty()) {
				newTask.setTaskStartTime(newTask.getTaskEndTime());
			}
			if (!newTask.taskStartTimeIsEmpty() && newTask.taskEndTimeIsEmpty()) {
				newTask.setTaskEndTime(newTask.getTaskStartTime());
			}
		}
	}

	private String removeSlashes(String date) {
		date = date.replaceAll("/", "");
		return date;
	}

	private String addOneDay(String date, String time) {
		Calendar initialTime = Calendar.getInstance();
		SimpleDateFormat dateFormatter = new SimpleDateFormat(SIMPLEDATETIMEFORMAT);
		time = getCurrentTime();
		initialTime.set(Integer.parseInt(date.substring(4, 6)), Integer.parseInt(date.substring(2, 4)) - 1,
				Integer.parseInt(date.substring(0, 2)), Integer.parseInt(time.substring(0, 2)),
				Integer.parseInt(time.substring(2, 4)), 0);
		initialTime.add(Calendar.HOUR, 24);
		String[] timeInfo = dateFormatter.format(initialTime.getTime()).split(" ");
		return timeInfo[0];

	}

	private String[] addOneHour(String date, String time) {
		Calendar initialTime = Calendar.getInstance();
		initialTime.set(Integer.parseInt(date.substring(4, 6)), Integer.parseInt(date.substring(2, 4)) - 1,
				Integer.parseInt(date.substring(0, 2)), Integer.parseInt(time.substring(0, 2)),
				Integer.parseInt(time.substring(2, 4)), 0);
		initialTime.add(Calendar.HOUR, 1);
		SimpleDateFormat dateFormatter = new SimpleDateFormat(SIMPLEDATETIMEFORMAT);
		String[] timeInfo = dateFormatter.format(initialTime.getTime()).split(" ");
		return timeInfo;
	}

	public String getCurrentDate() {
		DateFormat df = new SimpleDateFormat(DATETIMEFORMAT);
		Date dateobj = new Date();
		String currentDate = df.format(dateobj);
		return currentDate;
	}

	public String getCurrentTime() {
		DateFormat df = new SimpleDateFormat("HHmm");
		Calendar calobj = Calendar.getInstance();
		String time = df.format(calobj.getTime());
		return time;
	}

	// 0 for date 1 for time
	private String[] getTimeInfo(String[] commandParts, Task newTask, int wordIndex) throws Exception {
		logger.log(Level.INFO, "Parsing time");
		String[] timeInfo = new String[2];
		timeInfo[0] = "-1";
		timeInfo[1] = "-1";

		String currentDate = getCurrentDate();
		String currentTime = getCurrentTime();
		String taskOn = commandParts[wordIndex];
		// trim and comma is present
		if (commandParts[wordIndex].contains(",")) {
			if (!(commandParts[wordIndex].indexOf(",") == commandParts[wordIndex].length() - 1)) {
				throw new Exception("Comma has no spacing");
			}
		}

		int parseCount = 1;
		for (int i = 0; i < parseCount; i++) {
			taskOn = commandParts[wordIndex];
			if (commandParts[wordIndex].contains(",")) {
				taskOn = commandParts[wordIndex].substring(0, commandParts[wordIndex].indexOf(","));
				parseCount = 2;
			}
			taskOn = removeSlashes(taskOn);
			if (!(taskOn.matches("[0-9]+") && ((taskOn.length() == 4) || (taskOn.length() == 6))
					|| (taskOn.equals(KEYWORD_TOMORROW)))) {
				throw new Exception("Invalid date/time format");
			}
			if (taskOn.length() == 4) {
				int taskOnInt = Integer.valueOf(taskOn);
				if (taskOnInt >= 2400 || taskOnInt < 0) {
					throw new Exception("Time out of range");
				}
				timeInfo[1] = taskOn;
			} else if (taskOn.length() == 6) {
				if (!isDateValid(taskOn)) {
					throw new Exception("Invalid Date");
				}
				timeInfo[0] = taskOn;
			} else if (taskOn.equals(KEYWORD_TOMORROW)) {
				String nextDate = addOneDay(currentDate, currentTime);
				timeInfo[0] = nextDate;
			}
			wordIndex++;
		}

		return timeInfo;
	}

	public boolean endDatePassed(String currentDate, String endDate) {

		int currentDay = parseInt(getDay(currentDate));
		int currentMonth = parseInt(getMonth(currentDate));
		int currentYear = parseInt(getYear(currentDate));
		int endDay = parseInt(getDay(endDate));
		int endMonth = parseInt(getMonth(endDate));
		int endYear = parseInt(getYear(endDate));

		if ((currentYear > endYear)) {
			return true;
		} else if ((currentMonth > endMonth) && (currentYear == endYear)) {
			return true;
		} else if ((currentDay > endDay) && (currentMonth == endMonth) && (currentYear == endYear)) {
			return true;
		} else {
			return false;
		}
	}

	public String getDay(String date) {
		return date.substring(0, 2);
	}

	public String getMonth(String date) {
		return date.substring(2, 4);
	}

	public String getYear(String date) {
		return date.substring(4, 6);
	}

	protected int parseInt(String str) {
		int i = 0;
		int num = 0;
		boolean isNeg = false;

		// Check for negative sign; if it's there, set the isNeg flag
		if (str.charAt(0) == '-') {
			isNeg = true;
			i = 1;
		}

		// Process each character of the string;
		while (i < str.length()) {
			num *= 10;
			num += str.charAt(i++) - '0'; // Minus the ASCII code of '0' to get
											// the value of the charAt(i++).
		}

		if (isNeg)
			num = -num;
		return num;
	}

	public static boolean isDateValid(String date) {
		try {
			DateFormat df = new SimpleDateFormat(DATETIMEFORMAT);
			df.setLenient(false);
			df.parse(date);
			return true;
		} catch (ParseException e) {
			return false;
		}
	}
}
```
###### main\src\LemonBuddy\CommandController.java
``` java
package LemonBuddy;

import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
public class CommandController {
	private static final String TASKTYPE_OVERDUE = "overdue";

	private static final String TASKTYPE_DONE = "done";

	private static final String TASKTYPE_EVENT = "Event";

	private static final String TASKTYPE_DEADLINE = "Deadline";

	private static final String TASKTYPE_FLOATING = "Floating";

	private static Logger logger = Logger.getLogger("CommandController");

	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_DELETE = "delete";
	private static final String COMMAND_EDIT = "edit";
	private static final String COMMAND_VIEW = "view";
	private static final String COMMAND_LIST = "list";
	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_REDO = "redo";
	private static final String COMMAND_DONE = TASKTYPE_DONE;
	private static final String COMMAND_SEARCH = "search";
	private static CommandExecutor commandexecutor;
	private static CommandController commandcontroller;

	private static boolean isSuccesful;
	private static String commandType;
	private static String errorMessage;

	public CommandController() throws Exception {
		commandexecutor = CommandExecutor.getInstance();
		commandexecutor.saveLastState();
		commandexecutor.updateLists();
	}

	public static CommandController getInstance() throws IOException, Exception {
		if (commandcontroller == null) {
			commandcontroller = new CommandController();
		}
		return commandcontroller;

	}

	public void processCommand(String command) {
		logger.log(Level.INFO, "going to start processing");
		try {
			String[] commandParts = commandcontroller.splitCommand(command);
			commandType = commandParts[0];

			executeSaveLastState(commandType);

			switch (commandType) {
			case COMMAND_ADD:
				commandexecutor.executeAdd(commandParts);
				isSuccesful = true;
				break;

			case COMMAND_DELETE:
				if (commandParts[1].matches("[0-9]+") == false) {
					throw new Exception("Index is not in numerical form");
				}
				commandexecutor.executeDelete(commandParts);
				isSuccesful = true;
				break;

			case COMMAND_EDIT:
				if (commandParts[1].matches("[0-9]+") == false) {
					throw new Exception("Index is not in numerical form");
				}
				commandexecutor.executeEdit(commandParts);
				isSuccesful = true;
				break;

			case COMMAND_UNDO:
				commandexecutor.executeUndo();
				isSuccesful = true;
				break;

			case COMMAND_REDO:
				commandexecutor.executeRedo();
				isSuccesful = true;
				break;

			case COMMAND_VIEW:
				DateFormat df = new SimpleDateFormat("ddMMyy");
				df.setLenient(false);
				df.parse(commandParts[1]);
				commandexecutor.executeView(commandParts);
				isSuccesful = true;
				break;

			case COMMAND_LIST:
				if (!(commandParts[1].equals(TASKTYPE_FLOATING) || commandParts[1].equals(TASKTYPE_DEADLINE)
						|| commandParts[1].equals(TASKTYPE_EVENT) || commandParts[1].equals(TASKTYPE_DONE)
						|| commandParts[1].equals(TASKTYPE_OVERDUE))) {
					throw new Exception("Invalid task type");
				}
				commandexecutor.executeList(commandParts);
				isSuccesful = true;
				break;

			case COMMAND_DONE:
				if ((commandParts[1].matches("[0-9]+") == false)) {
					throw new Exception("Index is not in numerical form");
				}
				commandexecutor.executeDone(commandParts);
				isSuccesful = true;
				break;

			case COMMAND_SEARCH:
				commandexecutor.executeSearch(commandParts);
				isSuccesful = true;
				break;
			case "exit":
				System.exit(0);
			default:
				throw new Exception("Invalid Command");
			}

		} catch (Exception e) {
			logger.log(Level.WARNING, "processing error", e);
			errorMessage = (e.toString());
			isSuccesful = false;
		}

	}
```
###### main\src\LemonBuddy\CommandExecutor.java
``` java
package LemonBuddy;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandExecutor extends FileStorage {
	private static final String TASKTYPE_EVENT = "event";
	private static final String TASKTYPE_DEADLINE = "deadline";
	private static final String TASKTYPE_overdue = "overdue";
	private static final String TASKTYPE_done = "done";
	private static final String TASKTYPE_FLOATING = "floating";
	private static final java.util.logging.Logger logger = Logger.getLogger("CommandExecutor");

	private static String path;
	private Parser parser;
	String lastState;
	Stack<String> lastStates;
	Stack<String> undoneStates;

	private static String listType;

	private static ArrayList<Task> floatingTasks;
	private static ArrayList<Task> deadlineTasks;
	private static ArrayList<Task> eventTasks;
	private static ArrayList<Task> allTasks;
	private static ArrayList<Task> doneTasks;
	private static ArrayList<Task> overdueTasks;
	private static ArrayList<Task> listToTimeline;
	private static ArrayList<Task> searchResults;
	private static String[] date = { "", "" };
	private static CommandExecutor commandexecutor;
	private static Task selectedTask;

	public CommandExecutor() throws Exception {
		parser = Parser.getInstance();
		listType = "overdue";
		date[1] = parser.getCurrentDate();
		lastStates = new Stack<String>();
		undoneStates = new Stack<String>();
		lastState = "";
		path = "";
		floatingTasks = new ArrayList<Task>();
		deadlineTasks = new ArrayList<Task>();
		eventTasks = new ArrayList<Task>();
		allTasks = new ArrayList<Task>();
		doneTasks = new ArrayList<Task>();
		overdueTasks = new ArrayList<Task>();
		searchResults = new ArrayList<Task>();
	}

	public static CommandExecutor getInstance() throws Exception {
		if (commandexecutor == null) {
			commandexecutor = new CommandExecutor();
		}
		return commandexecutor;
	}

	public void updateLists() throws Exception {
		ArrayList<ArrayList<Task>> updatedLists = FileStorage.readStringAsObject(path);
		removeNewest(updatedLists);
		floatingTasks = updatedLists.get(0);
		deadlineTasks = updatedLists.get(1);
		eventTasks = updatedLists.get(2);
		allTasks = updatedLists.get(3);
		doneTasks = updatedLists.get(4);
		overdueTasks = updatedLists.get(5);
	}

	public void removeNewest(ArrayList<ArrayList<Task>> updatedLists) {
		for (int counter = 0; counter < updatedLists.size(); counter++) {
			for (int counter1 = 0; counter1 < updatedLists.get(counter).size(); counter1++) {
				if (updatedLists.get(counter).get(counter1).getTaskIsNewest()) {
					updatedLists.get(counter).get(counter1).removeTaskIsNewest();
				}
			}
		}
	}

	public void executeAdd(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing Add");
		Task newTask = parser.parseTask(commandParts);
		newTask.setTaskIsNewest();
		addTaskToList(newTask);
		selectedTask = newTask;
		writeToFile();
	}

	public void executeEdit(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing edit");
		int deleteIndex = Integer.valueOf(commandParts[1]);
		String[] stringToParse = getStringForParsing(commandParts);
		Task newTask = parser.parseTask(stringToParse);
		Task oldTask = deleteTaskFromList(deleteIndex);
		newTask.mergeTaskDetails(oldTask);
		addTaskToList(newTask);
		selectedTask = newTask;
		listType = newTask.getTaskType();
		writeToFile();
		updateLists();
	}

	public void executeSearch(String[] commandParts) throws ClassNotFoundException, IOException {
		searchResults.clear();
		listType = "search";
		int phraseSize = commandParts.length - 1;
		String searchKeyword = commandParts[1];
		if (phraseSize > 1) {
			for (int i = 2; i < phraseSize + 1; i++) {
				searchKeyword += " ";
				searchKeyword += commandParts[i];
			}
		}

		searchKeyword.toLowerCase();

		for (int j = 0; j < allTasks.size(); j++) {
			Task searchedTask = allTasks.get(j);
			if (searchedTask.getTaskName().toLowerCase().contains(searchKeyword)
					|| searchedTask.getTaskDescription().toLowerCase().contains(searchKeyword)) {
				searchResults.add(searchedTask);
			}
		}
		;
	}

	public void executeDelete(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing Delete");
		int deleteId = Integer.valueOf(commandParts[1]);
		deleteTaskFromList(deleteId);
		writeToFile();
	}

	public void executeList(String[] commandParts) throws Exception {
		listType = commandParts[1];
	}

	public void executeUndo() throws IOException, Exception {
		if (lastStates.isEmpty()) {
			throw new Exception("Already at last undo");
		}
		undoneStates.push(FileStorage.readStringAsString(path));
		FileStorage.clear();
		FileStorage.writeStringAsString(lastStates.pop());
		updateLists();
	}

	public void executeDone(String[] commandParts) throws Exception, IOException {
		int deleteID = Integer.valueOf(commandParts[1]);
		Task doneTask = deleteTaskFromList(deleteID);
		doneTask.setTaskType("done");
		doneTasks.add(doneTask);
		writeToFile();
	}

	public void executeView(String[] commandParts) throws ClassNotFoundException, IOException, ParseException {
		logger.log(Level.INFO, "Executing View");
		listType = "date";
		date[1] = commandParts[1];
		SimpleDateFormat sdf = new SimpleDateFormat("ddMMyy");
		Date dateToView = sdf.parse(date[1]);
		ArrayList<Task> tasksOnDate = new ArrayList<Task>();
		Task currentTask;
		for (int index = 0; index < eventTasks.size(); index++) {
			currentTask = eventTasks.get(index);
			Date dateStart = sdf.parse(currentTask.getTaskStartDate());
			Date dateEnd = sdf.parse(currentTask.getTaskEndDate());
			if ((dateEnd.compareTo(dateToView) >= 0) && (dateStart.compareTo(dateToView) <= 0)) {
				fillUpTime(currentTask);
				tasksOnDate.add(currentTask);
			}
		}

		ArrayList<Task> temp = new ArrayList<Task>();
		temp.addAll(deadlineTasks);
		temp.addAll(overdueTasks);
		for (int index = 0; index < temp.size(); index++) {
			currentTask = temp.get(index);
			if (currentTask.getTaskEndDate().equals(date[1])) {
				fillUpTime(currentTask);
				tasksOnDate.add(currentTask);
			}
		}
		listToTimeline = Sort.sortByTime(tasksOnDate);
	}

```
###### main\src\LemonBuddy\Parser.java
``` java
package LemonBuddy;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Parser {

	private static final String DATETIMEFORMAT = "ddMMyy";
	private static final String KEYWORD_TO = "to";
	private static final String SIMPLEDATETIMEFORMAT = "ddMMyy HHmm";
	private static final String KEYWORD_TOMORROW = "tomorrow";
	private static final String KEYWORD_BY = "by";
	private static final String KEYWORD_DESCRIPTION = "desc";
	private static final String KEYWORD_PRIORITY = "*";
	private static final String KEYWORD_FROM = "from";
	
	private static final String KEYWORD_ON = "on";
	private static final String TASKTYPE_DEADLINE = "deadline";
	private static final String TASKTYPE_EVENT = "event";
	private static Parser parser;
	private static Logger logger = Logger.getLogger("Parser");
	
	public static Parser getInstance(){
		if(parser == null)
			parser = new Parser();
		return parser;
	}
	/***************************************Create Task from string ******************************************************************/
	public Task parseTask(String[] commandParts) throws Exception {
		logger.log(Level.INFO, "Executing parse task");
		Task newTask = new Task();
		int wordIndex = 1;
		String taskName = "";
		parseTaskName(commandParts, newTask, wordIndex, taskName);
		parseDescription(commandParts, newTask, wordIndex);
		parsePriority(commandParts, newTask, wordIndex);
		parseTime(commandParts, newTask, wordIndex);

		return newTask;
	}

	/************************************** Builds name until first keyword ******************************************************************/
	private int parseTaskName(String[] commandParts, Task newTask, int wordIndex, String taskName) {
		logger.log(Level.INFO, "Parsing Name");
		while (true) {

			if (commandParts[wordIndex].equals(KEYWORD_ON) || commandParts[wordIndex].equals(KEYWORD_FROM)
					|| commandParts[wordIndex].substring(0, 1).equals(KEYWORD_PRIORITY)
					|| commandParts[wordIndex].equals(KEYWORD_DESCRIPTION)
					|| commandParts[wordIndex].equals(KEYWORD_BY)) {
				break;
			}
			taskName = taskName + commandParts[wordIndex++];
			if (wordIndex >= commandParts.length) {
				break;
			}
			taskName = taskName + " ";
		}
		taskName = taskName.trim();
		newTask.setTaskName(taskName);
		return wordIndex;
	}

	/**************************************** Builds description after KEYWORD_DESCRIPTION *****************************************/
	private int parseDescription(String[] commandParts, Task newTask, int wordIndex) {
		logger.log(Level.INFO, "Parsing description");
		int initialIndex = wordIndex;
		while (wordIndex < commandParts.length) {
			if (commandParts[wordIndex].equals(KEYWORD_DESCRIPTION)) {
				String taskDesc = "";
				wordIndex++;
				while (true) {
					taskDesc = taskDesc + commandParts[wordIndex++];
					if (wordIndex == commandParts.length) {
						break;
					}
					taskDesc = taskDesc + " ";
				}
				newTask.setTaskDescription(taskDesc);
			}
			wordIndex++;
		}
		return initialIndex;
	}

	/********************************* Builds priority after detecting KEYWORD_PRIORITY *******************/
	private int parsePriority(String[] commandParts, Task newTask, int wordIndex) throws Exception {
		logger.log(Level.INFO, "Parsing priority");
		int initialIndex = wordIndex;
		while (wordIndex < commandParts.length) {
			if (commandParts[wordIndex].substring(0, 1).equals(KEYWORD_PRIORITY)) {
				newTask.setTaskPriority(commandParts[wordIndex].substring(1));
			}
			wordIndex++;
		}
		return initialIndex;
	}

	private int parseTime(String[] commandParts, Task newTask, int wordIndex) throws Exception {

		detectFromToFormat(commandParts);
		setInputTime(commandParts, newTask, wordIndex);
		setFromToDefaultTime(newTask);
		setDeadlineDefaultTime(newTask);

		checkValidDateTimeInput(newTask);
		return wordIndex;
	}

	private void checkValidDateTimeInput(Task newTask) throws ParseException, Exception {
		if (newTask.getTaskType().equals(TASKTYPE_EVENT)) {

			SimpleDateFormat sdf = new SimpleDateFormat(DATETIMEFORMAT);
			Date date1 = sdf.parse(newTask.getTaskStartDate());
			Date date2 = sdf.parse(newTask.getTaskEndDate());
			if (date1.after(date2)) {
				throw new Exception("Start date is after end date");
			}
			if (newTask.getTaskStartDate().equals(newTask.getTaskEndDate())) {
				if (Integer.parseInt(newTask.getTaskStartTime()) > Integer.parseInt(newTask.getTaskEndTime())) {
					throw new Exception("Start time is after end time");
				}
			}
		}
	}

	private void setInputTime(String[] commandParts, Task newTask, int wordIndex) throws Exception {
		String[] timeInfo = new String[2];
		while (wordIndex < commandParts.length) {
			if (commandParts[wordIndex].equals(KEYWORD_DESCRIPTION)) {
				break;
			}
			switch (commandParts[wordIndex++]) {

			case KEYWORD_ON:
				timeInfo = getTimeInfo(commandParts, newTask, wordIndex);
				newTask.setTaskStartDate(timeInfo[0]);
				newTask.setTaskStartTime(timeInfo[1]);
				setOnDefaultTime(newTask);
				timeInfo = addOneHour(newTask.getTaskStartDate(), newTask.getTaskStartTime());
				newTask.setTaskEndDate(timeInfo[0]);
				newTask.setTaskEndTime(timeInfo[1]);

				newTask.setTaskType(TASKTYPE_EVENT);
				break;
			case KEYWORD_BY:
				timeInfo = getTimeInfo(commandParts, newTask, wordIndex);
				newTask.setTaskEndDate(timeInfo[0]);
				newTask.setTaskEndTime(timeInfo[1]);
				newTask.setTaskType(TASKTYPE_DEADLINE);
				break;
			case KEYWORD_FROM:
				timeInfo = getTimeInfo(commandParts, newTask, wordIndex);
				newTask.setTaskStartDate(timeInfo[0]);
				newTask.setTaskStartTime(timeInfo[1]);
				for (int i = wordIndex; i < commandParts.length; i++) {
					if (commandParts[i].equals(KEYWORD_TO)) {
						i++;
						wordIndex = i;
						break;
					}
				}
				timeInfo = getTimeInfo(commandParts, newTask, wordIndex);

				newTask.setTaskEndDate(timeInfo[0]);
				newTask.setTaskEndTime(timeInfo[1]);
				newTask.setTaskType(TASKTYPE_EVENT);
				break;
			}

		}
	}

	private void setOnDefaultTime(Task newTask) {
		if (newTask.taskStartDateIsEmpty() && newTask.taskEndDateIsEmpty()) {
			newTask.setTaskStartDate(getCurrentDate());
			newTask.setTaskEndDate(getCurrentDate());
		}
		if (newTask.taskStartDateIsEmpty() && !newTask.taskEndDateIsEmpty()) {
			newTask.setTaskStartDate(newTask.getTaskEndDate());
		}
		if (!newTask.taskStartDateIsEmpty() && newTask.taskEndDateIsEmpty()) {
			newTask.setTaskEndDate(newTask.getTaskStartDate());
		}
		if (newTask.taskStartTimeIsEmpty() && newTask.taskEndTimeIsEmpty()) {
			newTask.setTaskStartTime(getCurrentTime());
			newTask.setTaskEndTime(getCurrentTime());
		}
	}

```
###### main\src\LemonBuddy\Task.java
``` java
package LemonBuddy;

import java.io.Serializable;
import java.util.ArrayList;

import javafx.beans.property.SimpleStringProperty;

public class Task implements Serializable {
	private String taskName;
	private String taskType;
	private String taskStartDate;
	private String taskEndDate;
	private String taskPriority;
	private String taskDescription;
	private boolean taskIsDone;
	private boolean taskIsOverdue;
	private boolean taskIsNewest;
	private String taskStartTime;
	private String taskEndTime;

	private SimpleStringProperty displayId;
	private SimpleStringProperty displayName;
	private SimpleStringProperty displayStartDate;
	private SimpleStringProperty displayEndDate;
	private SimpleStringProperty displayStartTime;
	private SimpleStringProperty displayEndTime;
	private SimpleStringProperty displayPriority;
	private SimpleStringProperty displayDescription;
	private SimpleStringProperty[] displayTimmings = new SimpleStringProperty[48];
	
	public String toString() {
		String temp = "";
		temp = temp + "taskname:" + taskName + ";";
		temp = temp + "tasktype:" + taskType + ";";
		temp = temp + "taskIsDone:" + taskIsDone + ";";
		temp = temp + "taskIsOverdue:" + taskIsOverdue + ";";
		temp = temp + "taskIsNewest:" + taskIsNewest + ";";
		temp = temp + "taskStartDate:" + taskStartDate + ";";
		temp = temp + "taskEndDate:" + taskEndDate + ";";
		temp = temp + "taskPriority:" + taskPriority + ";";
		temp = temp + "taskDescription:" + taskDescription + ";";
		temp = temp + "taskStartTime:" + taskStartTime + ";";
		temp = temp + "taskEndTime:" + taskEndTime + ";";
		temp = temp + "\n";
		return temp;
	}

	//initializer
	public Task(){
		taskName = "";
		taskType = "floating";
		taskStartDate = "-1";
		taskEndDate = "-1";
		taskPriority = "low";
		taskDescription = "";
		taskIsDone = false;
		taskIsOverdue = false;
		taskIsNewest = false;
		taskStartTime = "-1";
		taskEndTime = "-1";
	}
	
	//TASK DATA MODIFIERS//
	
	public Task mergeTaskDetails(Task initialTask) {
		if (this.taskName.equals("")) {
			this.taskName = initialTask.getTaskName();
		}
		if (this.taskType.equals("floating")) {
			this.taskType = initialTask.getTaskType();
			this.taskStartDate = initialTask.getTaskStartDate();
			this.taskEndDate = initialTask.getTaskEndDate();
			this.taskStartTime = initialTask.getTaskStartTime();
			this.taskEndTime = initialTask.getTaskEndTime();
		}
		if (this.taskPriority.equals("low")) {
			this.taskPriority = initialTask.getTaskPriority();
		}
		if (this.taskDescription.equals("")) {
			this.taskDescription = initialTask.getTaskDescription();
		}
		return this;
	}

	public void setTaskName(String taskName) {
		this.taskName = taskName;
		this.displayName = new SimpleStringProperty(taskName);
	}

	public void setTaskType(String taskType) {
		this.taskType = taskType;
	}

	public void setTaskIsDone() {
		this.taskIsDone = true;
	}

	public void setTaskIsOverdue() {
		this.taskIsOverdue = true;
	}

	public void setTaskIsNewest() {
		this.taskIsNewest = true;
	}

	public void removeTaskIsNewest() {
		this.taskIsNewest = false;
	}

	public void setTaskStartDate(String taskStartDate) {
		this.taskStartDate = taskStartDate.replaceAll("[^\\d-]", "");
		this.displayStartDate = new SimpleStringProperty(this.taskStartDate);
	}

	public void setTaskEndDate(String taskEndDate) {
		this.taskEndDate = taskEndDate.replaceAll("[^\\d-]", "");
		this.displayEndDate = new SimpleStringProperty(this.taskEndDate);
	}

	public void setTaskStartTime(String taskStartTime) {
		this.taskStartTime = taskStartTime.replaceAll("[^\\d-]", "");
		this.displayStartTime = new SimpleStringProperty(this.taskStartTime);
	}

	public void setTaskEndTime(String taskEndTime) {
		this.taskEndTime = taskEndTime.replaceAll("[^\\d-]", "");
		this.displayEndTime = new SimpleStringProperty(this.taskEndTime);
	}

	public void setTaskPriority(String taskPriority) throws Exception {
		if(!(taskPriority.equals("low")||taskPriority.equals("medium")||taskPriority.equals("high"))){
			throw new Exception("Invalid priority type");
		}
		this.taskPriority = taskPriority;
		this.displayPriority = new SimpleStringProperty(this.taskPriority);
	}

	public void setTaskDescription(String taskDescription) {
		this.taskDescription = taskDescription;
		this.displayDescription = new SimpleStringProperty(this.taskDescription);
	}
	
	public void setDisplayId(String index) {
		this.displayId = new SimpleStringProperty(index);
	}
```
###### main\src\LemonBuddy\Test\TestParser.java
``` java
package LemonBuddy.Test;

import LemonBuddy.Parser;
import LemonBuddy.StorageFunction;
import LemonBuddy.Task;
import LemonBuddy.CommandExecutor;

import org.junit.After;
import org.junit.Before;
import static org.junit.Assert.*;

import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.util.Calendar;
import java.util.Date;

import org.junit.Test;

public class TestParser {

	private Parser parser = new Parser();
	private Task testTask;
	private String storageString;

	private String currentDate;
	private String currentDateAfterOneHour;
	private String tomorrowDateAtCurrentTime;
	private String tomorrowDateAfterOneHour;
	private String currentTime;
	private String currentTimeAfterOneHour;

	@Before
	public void setUp() throws Exception {
		Calendar endDate = Calendar.getInstance();
		SimpleDateFormat dateFormatter = new SimpleDateFormat("ddMMyy HHmm");
		String initialDate = dateFormatter.format(endDate.getTime());
		String[] timeInfo = dateFormatter.format(endDate.getTime()).split(" ");
		currentDate = timeInfo[0];
		currentTime = timeInfo[1];
		endDate.add(Calendar.HOUR, 1);
		timeInfo = dateFormatter.format(endDate.getTime()).split(" ");
		currentDateAfterOneHour = timeInfo[0];
		currentTimeAfterOneHour = timeInfo[1];

		endDate.add(Calendar.HOUR, 23);
		timeInfo = dateFormatter.format(endDate.getTime()).split(" ");
		tomorrowDateAtCurrentTime = timeInfo[0];

		endDate.add(Calendar.HOUR, 1);
		timeInfo = dateFormatter.format(endDate.getTime()).split(" ");
		tomorrowDateAfterOneHour = timeInfo[0];

		testTask = new Task();
		testTask.setTaskName("test one");
		testTask.setTaskType("event");
		testTask.setTaskIsNewest();
		testTask.setTaskStartDate("050516");
		testTask.setTaskEndDate("060516");
		testTask.setTaskStartTime("1400");
		testTask.setTaskEndTime("1600");
		testTask.setTaskPriority("high");
		testTask.setTaskDescription("hello world");

		storageString = "taskname:test one;tasktype:event;taskIsNewest:true;event;taskStartDate:050516;taskEndDate:060516;taskPriority:high;taskDescription:hello world;taskStartTime:1400;taskEndTime:1600;";

		// System.out.println(currentDate);
		// System.out.println(tomorrowDateAtCurrentTime);
		// System.out.println(tomorrowDateAfterOneHour);
		// System.out.println(currentTime);
		// System.out.println(currentTimeAfterOneHour);

	}

	@After
	public void tearDown() {
		parser = null;
		testTask = null;
		storageString = null;
	}

	public void testCompareTwoTasks(String[] commandParts, String expectedName, String expectedStartDate,
			String expectedEndDate, String expectedStartTime, String expectedEndTime, String expectedPriority,
			String expectedDescription) {
		try {
			Task task = parser.parseTask(commandParts);
			assertEquals(expectedName, ((Task) task).getTaskName());
			assertEquals(expectedStartDate, ((Task) task).getTaskStartDate());
			assertEquals(expectedEndDate, ((Task) task).getTaskEndDate());
			assertEquals(expectedStartTime, ((Task) task).getTaskStartTime());
			assertEquals(expectedEndTime, ((Task) task).getTaskEndTime());
			assertEquals(expectedPriority, ((Task) task).getTaskPriority());
			assertEquals(expectedDescription, ((Task) task).getTaskDescription());
		} catch (Exception e) {
			fail("Unknown exception");
		}
	}

	public void testInvalidTime(String[] commandParts, String expectedMessage) {
		Task task = new Task();
		String exceptionMessage = "";
		try {
			task = parser.parseTask(commandParts);
		} catch (Exception e) {
			exceptionMessage = e.getMessage();
		}
		assertEquals(expectedMessage, exceptionMessage);
	}

	public void testInvalidPriority(String[] commandParts, String expectedMessage) {
		Task task = new Task();
		String exceptionMessage = "";
		try {
			task = parser.parseTask(commandParts);
		} catch (Exception e) {
			exceptionMessage = e.getMessage();
		}
		System.out.println(exceptionMessage);
		assertEquals(expectedMessage, exceptionMessage);
	}

	public void testOverdue(String currentDate, String endDate, boolean expectedBoolean) {
		boolean isOverdue = parser.endDatePassed(currentDate, endDate);
		assertEquals(expectedBoolean, isOverdue);
	}

	//// --------------------------------------------------------------------------------------------------------///

	@Test
	public void executeTestParseEvent() {
		String[] commandParts = new String[50];

		commandParts = splitString("add spectacular spiderman on 1000, 12/12/15 *medium desc super");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "121215", "121215", "1000", "1100", "medium",
				"super");

		commandParts = splitString("add spectacular spiderman on 201225, 1200");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "201225", "201225", "1200", "1300", "low", "");

		commandParts = splitString("add spectacular spiderman on 1200, tomorrow");
		testCompareTwoTasks(commandParts, "spectacular spiderman", tomorrowDateAtCurrentTime, tomorrowDateAfterOneHour,
				"1200", "1300", "low", "");

		commandParts = splitString("add spectacular spiderman on tomorrow, 1200");
		testCompareTwoTasks(commandParts, "spectacular spiderman", tomorrowDateAtCurrentTime, tomorrowDateAtCurrentTime,
				"1200", "1300", "low", "");

		commandParts = splitString(
				"add spectacular spiderman from 1000, 12/12/15 to 1200, 13/12/15 *high desc super spec");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "121215", "131215", "1000", "1200", "high",
				"super spec");

		commandParts = splitString("add spectacular spiderman from 201225, 1200 to 221225, 1200");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "201225", "221225", "1200", "1200", "low", "");

		commandParts = splitString("add spectacular spiderman from 201225, 1200 to 221225, 1200");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "201225", "221225", "1200", "1200", "low", "");

		commandParts = splitString("add spectacular spiderman from 201225, 1200 to 221225, 1200");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "201225", "221225", "1200", "1200", "low", "");

	}

	@Test
	public void executeTestDefaultTimeEvent() {
		String[] commandParts = new String[50];

		commandParts = splitString("add spectacular spiderman on 2340 *medium desc super duper");
		testCompareTwoTasks(commandParts, "spectacular spiderman", currentDate, tomorrowDateAtCurrentTime, "2340",
				"0040", "medium", "super duper");

		commandParts = splitString("add spectacular spiderman on 201225");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "201225", "201225", currentTime,
				currentTimeAfterOneHour, "low", "");

		commandParts = splitString("add spectacular spiderman on tomorrow");
		testCompareTwoTasks(commandParts, "spectacular spiderman", tomorrowDateAtCurrentTime, tomorrowDateAtCurrentTime,
				currentTime, currentTimeAfterOneHour, "low", "");

		commandParts = splitString("add spectacular spiderman from 1000, 12/12/15 to 1200 *high desc super spec");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "121215", "121215", "1000", "1200", "high",
				"super spec");

		commandParts = splitString("add spectacular spiderman from 201225, 1200 to 221225");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "201225", "221225", "1200", "1200", "low", "");

		commandParts = splitString("add spectacular spiderman from 1200 to 221225, 1500");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "221225", "221225", "1200", "1500", "low", "");

		commandParts = splitString("add spectacular spiderman from 1200 to 221225");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "221225", "221225", "1200", "1200", "low", "");

		commandParts = splitString("add spectacular spiderman from 201225 to 221225");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "201225", "221225", "0000", "2359", "low", "");

		commandParts = splitString("add spectacular spiderman from 1000 to 1200");
		testCompareTwoTasks(commandParts, "spectacular spiderman", currentDate, currentDate, "1000", "1200", "low", "");

		commandParts = splitString("add spectacular spiderman from 251215 to 261215");
		testCompareTwoTasks(commandParts, "spectacular spiderman", "251215", "261215", "0000", "2359", "low", "");
	}

	@Test
	public void executeTestParseDeadline() {
		String[] commandParts = new String[50];

		commandParts = splitString("add bumbling bumblebee by 0010, 25/12/15");
		testCompareTwoTasks(commandParts, "bumbling bumblebee", "-1", "251215", "-1", "0010", "low", "");

		commandParts = splitString("add bumbling bumblebee by 1200, 261215 *medium desc fly high");
		testCompareTwoTasks(commandParts, "bumbling bumblebee", "-1", "261215", "-1", "1200", "medium", "fly high");

		commandParts = splitString("add bumbling bumblebee by 1010, tomorrow *medium desc fly high");
		testCompareTwoTasks(commandParts, "bumbling bumblebee", "-1", tomorrowDateAtCurrentTime, "-1", "1010", "medium",
				"fly high");

	}

	@Test
	public void executeTestDefaultTimeDeadline() {
		String[] commandParts = new String[50];

		commandParts = splitString("add bumbling bumblebee by 0010");
		testCompareTwoTasks(commandParts, "bumbling bumblebee", "-1", parser.getCurrentDate(), "-1", "0010", "low", "");

		commandParts = splitString("add bumbling bumblebee by 261215 *medium desc fly high");
		testCompareTwoTasks(commandParts, "bumbling bumblebee", "-1", "261215", "-1", parser.getCurrentTime(), "medium",
				"fly high");
	}

	@Test
	public void executeTestInvalidTime() {
		String[] commandParts = "add spectacular spiderman from 1200, 12/12/15 to 1100, 12/12/15 *high desc super spec"
				.split(" ");
		testInvalidTime(commandParts, "Start time is after end time");

		commandParts = "add spectacular spiderman from 2359, 11/12/15 to 0000, 10/12/15 *high desc super spec"
				.split(" ");
		testInvalidTime(commandParts, "Start date is after end date");

		commandParts = "add spectacular spiderman from 0000, 11/12/15 to 1100, 10/12/15 *high desc super spec"
				.split(" ");
		testInvalidTime(commandParts, "Start date is after end date");

		commandParts = "add spectacular spiderman from 0000, 11/12/15 to 2400, 11/12/15 *high desc super spec"
				.split(" ");
		testInvalidTime(commandParts, "Time out of range");

		commandParts = "add spectacular spiderman from 0000,11/12/15 to 2400, 11/12/15 *high desc super spec"
				.split(" ");
		testInvalidTime(commandParts, "Comma has no spacing");

		commandParts = "add spectacular spiderman from 0000, 11/1h/15 to 2400, 1a/12/15 *high desc super spec"
				.split(" ");
		testInvalidTime(commandParts, "Invalid date/time format");

		commandParts = "add spectacular spiderman from 0000, 11/1sh/15 to 2400, 1a/12/15 *high desc super spec"
				.split(" ");
		testInvalidTime(commandParts, "Invalid date/time format");
		commandParts = "add spectacular spiderman from -1, 11/12/15 to 2359, 11/12/15 *high desc super spec".split(" ");
		testInvalidTime(commandParts, "Invalid date/time format");
	}

	@Test
	public void executeTestInvalidPriority() {
		String[] commandParts = "add spectacular spiderman from 0000, 11/11/15 to 2350, 11/12/15 *higher desc super spec"
				.split(" ");
		testInvalidPriority(commandParts, "Invalid priority type");
	}

	@Test
	public void executeTestOverdue() {
		testOverdue("101010", "121010", false);
		testOverdue("121010", "121010", false);
		testOverdue("131010", "121010", true);
		
	}
	
	private String[] splitString(String command) {
		String[] commandParts = command.split(" ");
		return commandParts;
	}
}
```
